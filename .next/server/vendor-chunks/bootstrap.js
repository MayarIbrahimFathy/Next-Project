"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bootstrap";
exports.ids = ["vendor-chunks/bootstrap"];
exports.modules = {

/***/ "(ssr)/./node_modules/bootstrap/dist/js/bootstrap.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alert: () => (/* binding */ Alert),\n/* harmony export */   Button: () => (/* binding */ Button),\n/* harmony export */   Carousel: () => (/* binding */ Carousel),\n/* harmony export */   Collapse: () => (/* binding */ Collapse),\n/* harmony export */   Dropdown: () => (/* binding */ Dropdown),\n/* harmony export */   Modal: () => (/* binding */ Modal),\n/* harmony export */   Offcanvas: () => (/* binding */ Offcanvas),\n/* harmony export */   Popover: () => (/* binding */ Popover),\n/* harmony export */   ScrollSpy: () => (/* binding */ ScrollSpy),\n/* harmony export */   Tab: () => (/* binding */ Tab),\n/* harmony export */   Toast: () => (/* binding */ Toast),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip)\n/* harmony export */ });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/@popperjs/core/lib/index.js\");\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/@popperjs/core/lib/popper.js\");\n/*!\n  * Bootstrap v5.3.6 (https://getbootstrap.com/)\n  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */ \n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/data.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const elementMap = new Map();\nconst Data = {\n    set (element, key, instance) {\n        if (!elementMap.has(element)) {\n            elementMap.set(element, new Map());\n        }\n        const instanceMap = elementMap.get(element);\n        // make it clear we only want one instance per element\n        // can be removed later when multiple key/instances are fine to be used\n        if (!instanceMap.has(key) && instanceMap.size !== 0) {\n            // eslint-disable-next-line no-console\n            console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n            return;\n        }\n        instanceMap.set(key, instance);\n    },\n    get (element, key) {\n        if (elementMap.has(element)) {\n            return elementMap.get(element).get(key) || null;\n        }\n        return null;\n    },\n    remove (element, key) {\n        if (!elementMap.has(element)) {\n            return;\n        }\n        const instanceMap = elementMap.get(element);\n        instanceMap.delete(key);\n        // free up element references if there are no instances left for an element\n        if (instanceMap.size === 0) {\n            elementMap.delete(element);\n        }\n    }\n};\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/index.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ const MAX_UID = 1000000;\nconst MILLISECONDS_MULTIPLIER = 1000;\nconst TRANSITION_END = \"transitionend\";\n/**\n * Properly escape IDs selectors to handle weird IDs\n * @param {string} selector\n * @returns {string}\n */ const parseSelector = (selector)=>{\n    if (selector && window.CSS && window.CSS.escape) {\n        // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\n        selector = selector.replace(/#([^\\s\"#']+)/g, (match, id)=>`#${CSS.escape(id)}`);\n    }\n    return selector;\n};\n// Shout-out Angus Croll (https://goo.gl/pxwQGp)\nconst toType = (object)=>{\n    if (object === null || object === undefined) {\n        return `${object}`;\n    }\n    return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n};\n/**\n * Public Util API\n */ const getUID = (prefix)=>{\n    do {\n        prefix += Math.floor(Math.random() * MAX_UID);\n    }while (document.getElementById(prefix));\n    return prefix;\n};\nconst getTransitionDurationFromElement = (element)=>{\n    if (!element) {\n        return 0;\n    }\n    // Get transition-duration of the element\n    let { transitionDuration, transitionDelay } = window.getComputedStyle(element);\n    const floatTransitionDuration = Number.parseFloat(transitionDuration);\n    const floatTransitionDelay = Number.parseFloat(transitionDelay);\n    // Return 0 if element or transition duration is not found\n    if (!floatTransitionDuration && !floatTransitionDelay) {\n        return 0;\n    }\n    // If multiple durations are defined, take the first\n    transitionDuration = transitionDuration.split(\",\")[0];\n    transitionDelay = transitionDelay.split(\",\")[0];\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n};\nconst triggerTransitionEnd = (element)=>{\n    element.dispatchEvent(new Event(TRANSITION_END));\n};\nconst isElement = (object)=>{\n    if (!object || typeof object !== \"object\") {\n        return false;\n    }\n    if (typeof object.jquery !== \"undefined\") {\n        object = object[0];\n    }\n    return typeof object.nodeType !== \"undefined\";\n};\nconst getElement = (object)=>{\n    // it's a jQuery object or a node element\n    if (isElement(object)) {\n        return object.jquery ? object[0] : object;\n    }\n    if (typeof object === \"string\" && object.length > 0) {\n        return document.querySelector(parseSelector(object));\n    }\n    return null;\n};\nconst isVisible = (element)=>{\n    if (!isElement(element) || element.getClientRects().length === 0) {\n        return false;\n    }\n    const elementIsVisible = getComputedStyle(element).getPropertyValue(\"visibility\") === \"visible\";\n    // Handle `details` element as its content may falsie appear visible when it is closed\n    const closedDetails = element.closest(\"details:not([open])\");\n    if (!closedDetails) {\n        return elementIsVisible;\n    }\n    if (closedDetails !== element) {\n        const summary = element.closest(\"summary\");\n        if (summary && summary.parentNode !== closedDetails) {\n            return false;\n        }\n        if (summary === null) {\n            return false;\n        }\n    }\n    return elementIsVisible;\n};\nconst isDisabled = (element)=>{\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n        return true;\n    }\n    if (element.classList.contains(\"disabled\")) {\n        return true;\n    }\n    if (typeof element.disabled !== \"undefined\") {\n        return element.disabled;\n    }\n    return element.hasAttribute(\"disabled\") && element.getAttribute(\"disabled\") !== \"false\";\n};\nconst findShadowRoot = (element)=>{\n    if (!document.documentElement.attachShadow) {\n        return null;\n    }\n    // Can find the shadow root otherwise it'll return the document\n    if (typeof element.getRootNode === \"function\") {\n        const root = element.getRootNode();\n        return root instanceof ShadowRoot ? root : null;\n    }\n    if (element instanceof ShadowRoot) {\n        return element;\n    }\n    // when we don't find a shadow root\n    if (!element.parentNode) {\n        return null;\n    }\n    return findShadowRoot(element.parentNode);\n};\nconst noop = ()=>{};\n/**\n * Trick to restart an element's animation\n *\n * @param {HTMLElement} element\n * @return void\n *\n * @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n */ const reflow = (element)=>{\n    element.offsetHeight; // eslint-disable-line no-unused-expressions\n};\nconst getjQuery = ()=>{\n    if (window.jQuery && !document.body.hasAttribute(\"data-bs-no-jquery\")) {\n        return window.jQuery;\n    }\n    return null;\n};\nconst DOMContentLoadedCallbacks = [];\nconst onDOMContentLoaded = (callback)=>{\n    if (document.readyState === \"loading\") {\n        // add listener on the first call when the document is in loading state\n        if (!DOMContentLoadedCallbacks.length) {\n            document.addEventListener(\"DOMContentLoaded\", ()=>{\n                for (const callback of DOMContentLoadedCallbacks){\n                    callback();\n                }\n            });\n        }\n        DOMContentLoadedCallbacks.push(callback);\n    } else {\n        callback();\n    }\n};\nconst isRTL = ()=>document.documentElement.dir === \"rtl\";\nconst defineJQueryPlugin = (plugin)=>{\n    onDOMContentLoaded(()=>{\n        const $ = getjQuery();\n        /* istanbul ignore if */ if ($) {\n            const name = plugin.NAME;\n            const JQUERY_NO_CONFLICT = $.fn[name];\n            $.fn[name] = plugin.jQueryInterface;\n            $.fn[name].Constructor = plugin;\n            $.fn[name].noConflict = ()=>{\n                $.fn[name] = JQUERY_NO_CONFLICT;\n                return plugin.jQueryInterface;\n            };\n        }\n    });\n};\nconst execute = (possibleCallback, args = [], defaultValue = possibleCallback)=>{\n    return typeof possibleCallback === \"function\" ? possibleCallback.call(...args) : defaultValue;\n};\nconst executeAfterTransition = (callback, transitionElement, waitForTransition = true)=>{\n    if (!waitForTransition) {\n        execute(callback);\n        return;\n    }\n    const durationPadding = 5;\n    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n    let called = false;\n    const handler = ({ target })=>{\n        if (target !== transitionElement) {\n            return;\n        }\n        called = true;\n        transitionElement.removeEventListener(TRANSITION_END, handler);\n        execute(callback);\n    };\n    transitionElement.addEventListener(TRANSITION_END, handler);\n    setTimeout(()=>{\n        if (!called) {\n            triggerTransitionEnd(transitionElement);\n        }\n    }, emulatedDuration);\n};\n/**\n * Return the previous/next element of a list.\n *\n * @param {array} list    The list of elements\n * @param activeElement   The active element\n * @param shouldGetNext   Choose to get next or previous element\n * @param isCycleAllowed\n * @return {Element|elem} The proper element\n */ const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{\n    const listLength = list.length;\n    let index = list.indexOf(activeElement);\n    // if the element does not exist in the list return an element\n    // depending on the direction and if cycle is allowed\n    if (index === -1) {\n        return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n    }\n    index += shouldGetNext ? 1 : -1;\n    if (isCycleAllowed) {\n        index = (index + listLength) % listLength;\n    }\n    return list[Math.max(0, Math.min(index, listLength - 1))];\n};\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/event-handler.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\nconst stripNameRegex = /\\..*/;\nconst stripUidRegex = /::\\d+$/;\nconst eventRegistry = {}; // Events storage\nlet uidEvent = 1;\nconst customEvents = {\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n};\nconst nativeEvents = new Set([\n    \"click\",\n    \"dblclick\",\n    \"mouseup\",\n    \"mousedown\",\n    \"contextmenu\",\n    \"mousewheel\",\n    \"DOMMouseScroll\",\n    \"mouseover\",\n    \"mouseout\",\n    \"mousemove\",\n    \"selectstart\",\n    \"selectend\",\n    \"keydown\",\n    \"keypress\",\n    \"keyup\",\n    \"orientationchange\",\n    \"touchstart\",\n    \"touchmove\",\n    \"touchend\",\n    \"touchcancel\",\n    \"pointerdown\",\n    \"pointermove\",\n    \"pointerup\",\n    \"pointerleave\",\n    \"pointercancel\",\n    \"gesturestart\",\n    \"gesturechange\",\n    \"gestureend\",\n    \"focus\",\n    \"blur\",\n    \"change\",\n    \"reset\",\n    \"select\",\n    \"submit\",\n    \"focusin\",\n    \"focusout\",\n    \"load\",\n    \"unload\",\n    \"beforeunload\",\n    \"resize\",\n    \"move\",\n    \"DOMContentLoaded\",\n    \"readystatechange\",\n    \"error\",\n    \"abort\",\n    \"scroll\"\n]);\n/**\n * Private methods\n */ function makeEventUid(element, uid) {\n    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n}\nfunction getElementEvents(element) {\n    const uid = makeEventUid(element);\n    element.uidEvent = uid;\n    eventRegistry[uid] = eventRegistry[uid] || {};\n    return eventRegistry[uid];\n}\nfunction bootstrapHandler(element, fn) {\n    return function handler(event) {\n        hydrateObj(event, {\n            delegateTarget: element\n        });\n        if (handler.oneOff) {\n            EventHandler.off(element, event.type, fn);\n        }\n        return fn.apply(element, [\n            event\n        ]);\n    };\n}\nfunction bootstrapDelegationHandler(element, selector, fn) {\n    return function handler(event) {\n        const domElements = element.querySelectorAll(selector);\n        for(let { target } = event; target && target !== this; target = target.parentNode){\n            for (const domElement of domElements){\n                if (domElement !== target) {\n                    continue;\n                }\n                hydrateObj(event, {\n                    delegateTarget: target\n                });\n                if (handler.oneOff) {\n                    EventHandler.off(element, event.type, selector, fn);\n                }\n                return fn.apply(target, [\n                    event\n                ]);\n            }\n        }\n    };\n}\nfunction findHandler(events, callable, delegationSelector = null) {\n    return Object.values(events).find((event)=>event.callable === callable && event.delegationSelector === delegationSelector);\n}\nfunction normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n    const isDelegated = typeof handler === \"string\";\n    // TODO: tooltip passes `false` instead of selector, so we need to check\n    const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n    let typeEvent = getTypeEvent(originalTypeEvent);\n    if (!nativeEvents.has(typeEvent)) {\n        typeEvent = originalTypeEvent;\n    }\n    return [\n        isDelegated,\n        callable,\n        typeEvent\n    ];\n}\nfunction addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n    if (typeof originalTypeEvent !== \"string\" || !element) {\n        return;\n    }\n    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n    if (originalTypeEvent in customEvents) {\n        const wrapFunction = (fn)=>{\n            return function(event) {\n                if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n                    return fn.call(this, event);\n                }\n            };\n        };\n        callable = wrapFunction(callable);\n    }\n    const events = getElementEvents(element);\n    const handlers = events[typeEvent] || (events[typeEvent] = {});\n    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n    if (previousFunction) {\n        previousFunction.oneOff = previousFunction.oneOff && oneOff;\n        return;\n    }\n    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, \"\"));\n    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n    fn.delegationSelector = isDelegated ? handler : null;\n    fn.callable = callable;\n    fn.oneOff = oneOff;\n    fn.uidEvent = uid;\n    handlers[uid] = fn;\n    element.addEventListener(typeEvent, fn, isDelegated);\n}\nfunction removeHandler(element, events, typeEvent, handler, delegationSelector) {\n    const fn = findHandler(events[typeEvent], handler, delegationSelector);\n    if (!fn) {\n        return;\n    }\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n    delete events[typeEvent][fn.uidEvent];\n}\nfunction removeNamespacedHandlers(element, events, typeEvent, namespace) {\n    const storeElementEvent = events[typeEvent] || {};\n    for (const [handlerKey, event] of Object.entries(storeElementEvent)){\n        if (handlerKey.includes(namespace)) {\n            removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n        }\n    }\n}\nfunction getTypeEvent(event) {\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n    event = event.replace(stripNameRegex, \"\");\n    return customEvents[event] || event;\n}\nconst EventHandler = {\n    on (element, event, handler, delegationFunction) {\n        addHandler(element, event, handler, delegationFunction, false);\n    },\n    one (element, event, handler, delegationFunction) {\n        addHandler(element, event, handler, delegationFunction, true);\n    },\n    off (element, originalTypeEvent, handler, delegationFunction) {\n        if (typeof originalTypeEvent !== \"string\" || !element) {\n            return;\n        }\n        const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n        const inNamespace = typeEvent !== originalTypeEvent;\n        const events = getElementEvents(element);\n        const storeElementEvent = events[typeEvent] || {};\n        const isNamespace = originalTypeEvent.startsWith(\".\");\n        if (typeof callable !== \"undefined\") {\n            // Simplest case: handler is passed, remove that listener ONLY.\n            if (!Object.keys(storeElementEvent).length) {\n                return;\n            }\n            removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n            return;\n        }\n        if (isNamespace) {\n            for (const elementEvent of Object.keys(events)){\n                removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n            }\n        }\n        for (const [keyHandlers, event] of Object.entries(storeElementEvent)){\n            const handlerKey = keyHandlers.replace(stripUidRegex, \"\");\n            if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n                removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n            }\n        }\n    },\n    trigger (element, event, args) {\n        if (typeof event !== \"string\" || !element) {\n            return null;\n        }\n        const $ = getjQuery();\n        const typeEvent = getTypeEvent(event);\n        const inNamespace = event !== typeEvent;\n        let jQueryEvent = null;\n        let bubbles = true;\n        let nativeDispatch = true;\n        let defaultPrevented = false;\n        if (inNamespace && $) {\n            jQueryEvent = $.Event(event, args);\n            $(element).trigger(jQueryEvent);\n            bubbles = !jQueryEvent.isPropagationStopped();\n            nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n            defaultPrevented = jQueryEvent.isDefaultPrevented();\n        }\n        const evt = hydrateObj(new Event(event, {\n            bubbles,\n            cancelable: true\n        }), args);\n        if (defaultPrevented) {\n            evt.preventDefault();\n        }\n        if (nativeDispatch) {\n            element.dispatchEvent(evt);\n        }\n        if (evt.defaultPrevented && jQueryEvent) {\n            jQueryEvent.preventDefault();\n        }\n        return evt;\n    }\n};\nfunction hydrateObj(obj, meta = {}) {\n    for (const [key, value] of Object.entries(meta)){\n        try {\n            obj[key] = value;\n        } catch (_unused) {\n            Object.defineProperty(obj, key, {\n                configurable: true,\n                get () {\n                    return value;\n                }\n            });\n        }\n    }\n    return obj;\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/manipulator.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ function normalizeData(value) {\n    if (value === \"true\") {\n        return true;\n    }\n    if (value === \"false\") {\n        return false;\n    }\n    if (value === Number(value).toString()) {\n        return Number(value);\n    }\n    if (value === \"\" || value === \"null\") {\n        return null;\n    }\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    try {\n        return JSON.parse(decodeURIComponent(value));\n    } catch (_unused) {\n        return value;\n    }\n}\nfunction normalizeDataKey(key) {\n    return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`);\n}\nconst Manipulator = {\n    setDataAttribute (element, key, value) {\n        element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n    },\n    removeDataAttribute (element, key) {\n        element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n    },\n    getDataAttributes (element) {\n        if (!element) {\n            return {};\n        }\n        const attributes = {};\n        const bsKeys = Object.keys(element.dataset).filter((key)=>key.startsWith(\"bs\") && !key.startsWith(\"bsConfig\"));\n        for (const key of bsKeys){\n            let pureKey = key.replace(/^bs/, \"\");\n            pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);\n            attributes[pureKey] = normalizeData(element.dataset[key]);\n        }\n        return attributes;\n    },\n    getDataAttribute (element, key) {\n        return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n    }\n};\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/config.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Class definition\n */ class Config {\n    // Getters\n    static get Default() {\n        return {};\n    }\n    static get DefaultType() {\n        return {};\n    }\n    static get NAME() {\n        throw new Error('You have to implement the static method \"NAME\", for each component!');\n    }\n    _getConfig(config) {\n        config = this._mergeConfigObj(config);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n    }\n    _configAfterMerge(config) {\n        return config;\n    }\n    _mergeConfigObj(config, element) {\n        const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, \"config\") : {}; // try to parse\n        return {\n            ...this.constructor.Default,\n            ...typeof jsonConfig === \"object\" ? jsonConfig : {},\n            ...isElement(element) ? Manipulator.getDataAttributes(element) : {},\n            ...typeof config === \"object\" ? config : {}\n        };\n    }\n    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n        for (const [property, expectedTypes] of Object.entries(configTypes)){\n            const value = config[property];\n            const valueType = isElement(value) ? \"element\" : toType(value);\n            if (!new RegExp(expectedTypes).test(valueType)) {\n                throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n            }\n        }\n    }\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap base-component.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const VERSION = \"5.3.6\";\n/**\n * Class definition\n */ class BaseComponent extends Config {\n    constructor(element, config){\n        super();\n        element = getElement(element);\n        if (!element) {\n            return;\n        }\n        this._element = element;\n        this._config = this._getConfig(config);\n        Data.set(this._element, this.constructor.DATA_KEY, this);\n    }\n    // Public\n    dispose() {\n        Data.remove(this._element, this.constructor.DATA_KEY);\n        EventHandler.off(this._element, this.constructor.EVENT_KEY);\n        for (const propertyName of Object.getOwnPropertyNames(this)){\n            this[propertyName] = null;\n        }\n    }\n    // Private\n    _queueCallback(callback, element, isAnimated = true) {\n        executeAfterTransition(callback, element, isAnimated);\n    }\n    _getConfig(config) {\n        config = this._mergeConfigObj(config, this._element);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n    }\n    // Static\n    static getInstance(element) {\n        return Data.get(getElement(element), this.DATA_KEY);\n    }\n    static getOrCreateInstance(element, config = {}) {\n        return this.getInstance(element) || new this(element, typeof config === \"object\" ? config : null);\n    }\n    static get VERSION() {\n        return VERSION;\n    }\n    static get DATA_KEY() {\n        return `bs.${this.NAME}`;\n    }\n    static get EVENT_KEY() {\n        return `.${this.DATA_KEY}`;\n    }\n    static eventName(name) {\n        return `${name}${this.EVENT_KEY}`;\n    }\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/selector-engine.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ const getSelector = (element)=>{\n    let selector = element.getAttribute(\"data-bs-target\");\n    if (!selector || selector === \"#\") {\n        let hrefAttribute = element.getAttribute(\"href\");\n        // The only valid content that could double as a selector are IDs or classes,\n        // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n        // `document.querySelector` will rightfully complain it is invalid.\n        // See https://github.com/twbs/bootstrap/issues/32273\n        if (!hrefAttribute || !hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\".\")) {\n            return null;\n        }\n        // Just in case some CMS puts out a full URL with the anchor appended\n        if (hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\"#\")) {\n            hrefAttribute = `#${hrefAttribute.split(\"#\")[1]}`;\n        }\n        selector = hrefAttribute && hrefAttribute !== \"#\" ? hrefAttribute.trim() : null;\n    }\n    return selector ? selector.split(\",\").map((sel)=>parseSelector(sel)).join(\",\") : null;\n};\nconst SelectorEngine = {\n    find (selector, element = document.documentElement) {\n        return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n    },\n    findOne (selector, element = document.documentElement) {\n        return Element.prototype.querySelector.call(element, selector);\n    },\n    children (element, selector) {\n        return [].concat(...element.children).filter((child)=>child.matches(selector));\n    },\n    parents (element, selector) {\n        const parents = [];\n        let ancestor = element.parentNode.closest(selector);\n        while(ancestor){\n            parents.push(ancestor);\n            ancestor = ancestor.parentNode.closest(selector);\n        }\n        return parents;\n    },\n    prev (element, selector) {\n        let previous = element.previousElementSibling;\n        while(previous){\n            if (previous.matches(selector)) {\n                return [\n                    previous\n                ];\n            }\n            previous = previous.previousElementSibling;\n        }\n        return [];\n    },\n    // TODO: this is now unused; remove later along with prev()\n    next (element, selector) {\n        let next = element.nextElementSibling;\n        while(next){\n            if (next.matches(selector)) {\n                return [\n                    next\n                ];\n            }\n            next = next.nextElementSibling;\n        }\n        return [];\n    },\n    focusableChildren (element) {\n        const focusables = [\n            \"a\",\n            \"button\",\n            \"input\",\n            \"textarea\",\n            \"select\",\n            \"details\",\n            \"[tabindex]\",\n            '[contenteditable=\"true\"]'\n        ].map((selector)=>`${selector}:not([tabindex^=\"-\"])`).join(\",\");\n        return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el));\n    },\n    getSelectorFromElement (element) {\n        const selector = getSelector(element);\n        if (selector) {\n            return SelectorEngine.findOne(selector) ? selector : null;\n        }\n        return null;\n    },\n    getElementFromSelector (element) {\n        const selector = getSelector(element);\n        return selector ? SelectorEngine.findOne(selector) : null;\n    },\n    getMultipleElementsFromSelector (element) {\n        const selector = getSelector(element);\n        return selector ? SelectorEngine.find(selector) : [];\n    }\n};\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/component-functions.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ const enableDismissTrigger = (component, method = \"hide\")=>{\n    const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n    const name = component.NAME;\n    EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function(event) {\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        if (isDisabled(this)) {\n            return;\n        }\n        const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\n        const instance = component.getOrCreateInstance(target);\n        // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n        instance[method]();\n    });\n};\n/**\n * --------------------------------------------------------------------------\n * Bootstrap alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$f = \"alert\";\nconst DATA_KEY$a = \"bs.alert\";\nconst EVENT_KEY$b = `.${DATA_KEY$a}`;\nconst EVENT_CLOSE = `close${EVENT_KEY$b}`;\nconst EVENT_CLOSED = `closed${EVENT_KEY$b}`;\nconst CLASS_NAME_FADE$5 = \"fade\";\nconst CLASS_NAME_SHOW$8 = \"show\";\n/**\n * Class definition\n */ class Alert extends BaseComponent {\n    // Getters\n    static get NAME() {\n        return NAME$f;\n    }\n    // Public\n    close() {\n        const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n        if (closeEvent.defaultPrevented) {\n            return;\n        }\n        this._element.classList.remove(CLASS_NAME_SHOW$8);\n        const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n        this._queueCallback(()=>this._destroyElement(), this._element, isAnimated);\n    }\n    // Private\n    _destroyElement() {\n        this._element.remove();\n        EventHandler.trigger(this._element, EVENT_CLOSED);\n        this.dispose();\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Alert.getOrCreateInstance(this);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config](this);\n        });\n    }\n}\n/**\n * Data API implementation\n */ enableDismissTrigger(Alert, \"close\");\n/**\n * jQuery\n */ defineJQueryPlugin(Alert);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$e = \"button\";\nconst DATA_KEY$9 = \"bs.button\";\nconst EVENT_KEY$a = `.${DATA_KEY$9}`;\nconst DATA_API_KEY$6 = \".data-api\";\nconst CLASS_NAME_ACTIVE$3 = \"active\";\nconst SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\nconst EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\n/**\n * Class definition\n */ class Button extends BaseComponent {\n    // Getters\n    static get NAME() {\n        return NAME$e;\n    }\n    // Public\n    toggle() {\n        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n        this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Button.getOrCreateInstance(this);\n            if (config === \"toggle\") {\n                data[config]();\n            }\n        });\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{\n    event.preventDefault();\n    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n    const data = Button.getOrCreateInstance(button);\n    data.toggle();\n});\n/**\n * jQuery\n */ defineJQueryPlugin(Button);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/swipe.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$d = \"swipe\";\nconst EVENT_KEY$9 = \".bs.swipe\";\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\nconst POINTER_TYPE_TOUCH = \"touch\";\nconst POINTER_TYPE_PEN = \"pen\";\nconst CLASS_NAME_POINTER_EVENT = \"pointer-event\";\nconst SWIPE_THRESHOLD = 40;\nconst Default$c = {\n    endCallback: null,\n    leftCallback: null,\n    rightCallback: null\n};\nconst DefaultType$c = {\n    endCallback: \"(function|null)\",\n    leftCallback: \"(function|null)\",\n    rightCallback: \"(function|null)\"\n};\n/**\n * Class definition\n */ class Swipe extends Config {\n    constructor(element, config){\n        super();\n        this._element = element;\n        if (!element || !Swipe.isSupported()) {\n            return;\n        }\n        this._config = this._getConfig(config);\n        this._deltaX = 0;\n        this._supportPointerEvents = Boolean(window.PointerEvent);\n        this._initEvents();\n    }\n    // Getters\n    static get Default() {\n        return Default$c;\n    }\n    static get DefaultType() {\n        return DefaultType$c;\n    }\n    static get NAME() {\n        return NAME$d;\n    }\n    // Public\n    dispose() {\n        EventHandler.off(this._element, EVENT_KEY$9);\n    }\n    // Private\n    _start(event) {\n        if (!this._supportPointerEvents) {\n            this._deltaX = event.touches[0].clientX;\n            return;\n        }\n        if (this._eventIsPointerPenTouch(event)) {\n            this._deltaX = event.clientX;\n        }\n    }\n    _end(event) {\n        if (this._eventIsPointerPenTouch(event)) {\n            this._deltaX = event.clientX - this._deltaX;\n        }\n        this._handleSwipe();\n        execute(this._config.endCallback);\n    }\n    _move(event) {\n        this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n    }\n    _handleSwipe() {\n        const absDeltaX = Math.abs(this._deltaX);\n        if (absDeltaX <= SWIPE_THRESHOLD) {\n            return;\n        }\n        const direction = absDeltaX / this._deltaX;\n        this._deltaX = 0;\n        if (!direction) {\n            return;\n        }\n        execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n    }\n    _initEvents() {\n        if (this._supportPointerEvents) {\n            EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>this._start(event));\n            EventHandler.on(this._element, EVENT_POINTERUP, (event)=>this._end(event));\n            this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n        } else {\n            EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>this._start(event));\n            EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>this._move(event));\n            EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>this._end(event));\n        }\n    }\n    _eventIsPointerPenTouch(event) {\n        return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n    }\n    // Static\n    static isSupported() {\n        return \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0;\n    }\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$c = \"carousel\";\nconst DATA_KEY$8 = \"bs.carousel\";\nconst EVENT_KEY$8 = `.${DATA_KEY$8}`;\nconst DATA_API_KEY$5 = \".data-api\";\nconst ARROW_LEFT_KEY$1 = \"ArrowLeft\";\nconst ARROW_RIGHT_KEY$1 = \"ArrowRight\";\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\nconst ORDER_NEXT = \"next\";\nconst ORDER_PREV = \"prev\";\nconst DIRECTION_LEFT = \"left\";\nconst DIRECTION_RIGHT = \"right\";\nconst EVENT_SLIDE = `slide${EVENT_KEY$8}`;\nconst EVENT_SLID = `slid${EVENT_KEY$8}`;\nconst EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\nconst EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\nconst EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\nconst EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst CLASS_NAME_CAROUSEL = \"carousel\";\nconst CLASS_NAME_ACTIVE$2 = \"active\";\nconst CLASS_NAME_SLIDE = \"slide\";\nconst CLASS_NAME_END = \"carousel-item-end\";\nconst CLASS_NAME_START = \"carousel-item-start\";\nconst CLASS_NAME_NEXT = \"carousel-item-next\";\nconst CLASS_NAME_PREV = \"carousel-item-prev\";\nconst SELECTOR_ACTIVE = \".active\";\nconst SELECTOR_ITEM = \".carousel-item\";\nconst SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\nconst SELECTOR_ITEM_IMG = \".carousel-item img\";\nconst SELECTOR_INDICATORS = \".carousel-indicators\";\nconst SELECTOR_DATA_SLIDE = \"[data-bs-slide], [data-bs-slide-to]\";\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\nconst KEY_TO_DIRECTION = {\n    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n};\nconst Default$b = {\n    interval: 5000,\n    keyboard: true,\n    pause: \"hover\",\n    ride: false,\n    touch: true,\n    wrap: true\n};\nconst DefaultType$b = {\n    interval: \"(number|boolean)\",\n    // TODO:v6 remove boolean support\n    keyboard: \"boolean\",\n    pause: \"(string|boolean)\",\n    ride: \"(boolean|string)\",\n    touch: \"boolean\",\n    wrap: \"boolean\"\n};\n/**\n * Class definition\n */ class Carousel extends BaseComponent {\n    constructor(element, config){\n        super(element, config);\n        this._interval = null;\n        this._activeElement = null;\n        this._isSliding = false;\n        this.touchTimeout = null;\n        this._swipeHelper = null;\n        this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n        this._addEventListeners();\n        if (this._config.ride === CLASS_NAME_CAROUSEL) {\n            this.cycle();\n        }\n    }\n    // Getters\n    static get Default() {\n        return Default$b;\n    }\n    static get DefaultType() {\n        return DefaultType$b;\n    }\n    static get NAME() {\n        return NAME$c;\n    }\n    // Public\n    next() {\n        this._slide(ORDER_NEXT);\n    }\n    nextWhenVisible() {\n        // FIXME TODO use `document.visibilityState`\n        // Don't call next when the page isn't visible\n        // or the carousel or its parent isn't visible\n        if (!document.hidden && isVisible(this._element)) {\n            this.next();\n        }\n    }\n    prev() {\n        this._slide(ORDER_PREV);\n    }\n    pause() {\n        if (this._isSliding) {\n            triggerTransitionEnd(this._element);\n        }\n        this._clearInterval();\n    }\n    cycle() {\n        this._clearInterval();\n        this._updateInterval();\n        this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);\n    }\n    _maybeEnableCycle() {\n        if (!this._config.ride) {\n            return;\n        }\n        if (this._isSliding) {\n            EventHandler.one(this._element, EVENT_SLID, ()=>this.cycle());\n            return;\n        }\n        this.cycle();\n    }\n    to(index) {\n        const items = this._getItems();\n        if (index > items.length - 1 || index < 0) {\n            return;\n        }\n        if (this._isSliding) {\n            EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index));\n            return;\n        }\n        const activeIndex = this._getItemIndex(this._getActive());\n        if (activeIndex === index) {\n            return;\n        }\n        const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n        this._slide(order, items[index]);\n    }\n    dispose() {\n        if (this._swipeHelper) {\n            this._swipeHelper.dispose();\n        }\n        super.dispose();\n    }\n    // Private\n    _configAfterMerge(config) {\n        config.defaultInterval = config.interval;\n        return config;\n    }\n    _addEventListeners() {\n        if (this._config.keyboard) {\n            EventHandler.on(this._element, EVENT_KEYDOWN$1, (event)=>this._keydown(event));\n        }\n        if (this._config.pause === \"hover\") {\n            EventHandler.on(this._element, EVENT_MOUSEENTER$1, ()=>this.pause());\n            EventHandler.on(this._element, EVENT_MOUSELEAVE$1, ()=>this._maybeEnableCycle());\n        }\n        if (this._config.touch && Swipe.isSupported()) {\n            this._addTouchEventListeners();\n        }\n    }\n    _addTouchEventListeners() {\n        for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)){\n            EventHandler.on(img, EVENT_DRAG_START, (event)=>event.preventDefault());\n        }\n        const endCallBack = ()=>{\n            if (this._config.pause !== \"hover\") {\n                return;\n            }\n            // If it's a touch-enabled device, mouseenter/leave are fired as\n            // part of the mouse compatibility events on first tap - the carousel\n            // would stop cycling until user tapped out of it;\n            // here, we listen for touchend, explicitly pause the carousel\n            // (as if it's the second time we tap on it, mouseenter compat event\n            // is NOT fired) and after a timeout (to allow for mouse compatibility\n            // events to fire) we explicitly restart cycling\n            this.pause();\n            if (this.touchTimeout) {\n                clearTimeout(this.touchTimeout);\n            }\n            this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n        };\n        const swipeConfig = {\n            leftCallback: ()=>this._slide(this._directionToOrder(DIRECTION_LEFT)),\n            rightCallback: ()=>this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n            endCallback: endCallBack\n        };\n        this._swipeHelper = new Swipe(this._element, swipeConfig);\n    }\n    _keydown(event) {\n        if (/input|textarea/i.test(event.target.tagName)) {\n            return;\n        }\n        const direction = KEY_TO_DIRECTION[event.key];\n        if (direction) {\n            event.preventDefault();\n            this._slide(this._directionToOrder(direction));\n        }\n    }\n    _getItemIndex(element) {\n        return this._getItems().indexOf(element);\n    }\n    _setActiveIndicatorElement(index) {\n        if (!this._indicatorsElement) {\n            return;\n        }\n        const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n        activeIndicator.removeAttribute(\"aria-current\");\n        const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\n        if (newActiveIndicator) {\n            newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n            newActiveIndicator.setAttribute(\"aria-current\", \"true\");\n        }\n    }\n    _updateInterval() {\n        const element = this._activeElement || this._getActive();\n        if (!element) {\n            return;\n        }\n        const elementInterval = Number.parseInt(element.getAttribute(\"data-bs-interval\"), 10);\n        this._config.interval = elementInterval || this._config.defaultInterval;\n    }\n    _slide(order, element = null) {\n        if (this._isSliding) {\n            return;\n        }\n        const activeElement = this._getActive();\n        const isNext = order === ORDER_NEXT;\n        const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n        if (nextElement === activeElement) {\n            return;\n        }\n        const nextElementIndex = this._getItemIndex(nextElement);\n        const triggerEvent = (eventName)=>{\n            return EventHandler.trigger(this._element, eventName, {\n                relatedTarget: nextElement,\n                direction: this._orderToDirection(order),\n                from: this._getItemIndex(activeElement),\n                to: nextElementIndex\n            });\n        };\n        const slideEvent = triggerEvent(EVENT_SLIDE);\n        if (slideEvent.defaultPrevented) {\n            return;\n        }\n        if (!activeElement || !nextElement) {\n            // Some weirdness is happening, so we bail\n            // TODO: change tests that use empty divs to avoid this check\n            return;\n        }\n        const isCycling = Boolean(this._interval);\n        this.pause();\n        this._isSliding = true;\n        this._setActiveIndicatorElement(nextElementIndex);\n        this._activeElement = nextElement;\n        const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n        const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n        nextElement.classList.add(orderClassName);\n        reflow(nextElement);\n        activeElement.classList.add(directionalClassName);\n        nextElement.classList.add(directionalClassName);\n        const completeCallBack = ()=>{\n            nextElement.classList.remove(directionalClassName, orderClassName);\n            nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n            activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n            this._isSliding = false;\n            triggerEvent(EVENT_SLID);\n        };\n        this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n        if (isCycling) {\n            this.cycle();\n        }\n    }\n    _isAnimated() {\n        return this._element.classList.contains(CLASS_NAME_SLIDE);\n    }\n    _getActive() {\n        return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n    }\n    _getItems() {\n        return SelectorEngine.find(SELECTOR_ITEM, this._element);\n    }\n    _clearInterval() {\n        if (this._interval) {\n            clearInterval(this._interval);\n            this._interval = null;\n        }\n    }\n    _directionToOrder(direction) {\n        if (isRTL()) {\n            return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n        }\n        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n    }\n    _orderToDirection(order) {\n        if (isRTL()) {\n            return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Carousel.getOrCreateInstance(this, config);\n            if (typeof config === \"number\") {\n                data.to(config);\n                return;\n            }\n            if (typeof config === \"string\") {\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            }\n        });\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {\n    const target = SelectorEngine.getElementFromSelector(this);\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n        return;\n    }\n    event.preventDefault();\n    const carousel = Carousel.getOrCreateInstance(target);\n    const slideIndex = this.getAttribute(\"data-bs-slide-to\");\n    if (slideIndex) {\n        carousel.to(slideIndex);\n        carousel._maybeEnableCycle();\n        return;\n    }\n    if (Manipulator.getDataAttribute(this, \"slide\") === \"next\") {\n        carousel.next();\n        carousel._maybeEnableCycle();\n        return;\n    }\n    carousel.prev();\n    carousel._maybeEnableCycle();\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$3, ()=>{\n    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n    for (const carousel of carousels){\n        Carousel.getOrCreateInstance(carousel);\n    }\n});\n/**\n * jQuery\n */ defineJQueryPlugin(Carousel);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$b = \"collapse\";\nconst DATA_KEY$7 = \"bs.collapse\";\nconst EVENT_KEY$7 = `.${DATA_KEY$7}`;\nconst DATA_API_KEY$4 = \".data-api\";\nconst EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\nconst EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\nconst EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\nconst EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\nconst EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst CLASS_NAME_SHOW$7 = \"show\";\nconst CLASS_NAME_COLLAPSE = \"collapse\";\nconst CLASS_NAME_COLLAPSING = \"collapsing\";\nconst CLASS_NAME_COLLAPSED = \"collapsed\";\nconst CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\nconst CLASS_NAME_HORIZONTAL = \"collapse-horizontal\";\nconst WIDTH = \"width\";\nconst HEIGHT = \"height\";\nconst SELECTOR_ACTIVES = \".collapse.show, .collapse.collapsing\";\nconst SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\nconst Default$a = {\n    parent: null,\n    toggle: true\n};\nconst DefaultType$a = {\n    parent: \"(null|element)\",\n    toggle: \"boolean\"\n};\n/**\n * Class definition\n */ class Collapse extends BaseComponent {\n    constructor(element, config){\n        super(element, config);\n        this._isTransitioning = false;\n        this._triggerArray = [];\n        const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n        for (const elem of toggleList){\n            const selector = SelectorEngine.getSelectorFromElement(elem);\n            const filterElement = SelectorEngine.find(selector).filter((foundElement)=>foundElement === this._element);\n            if (selector !== null && filterElement.length) {\n                this._triggerArray.push(elem);\n            }\n        }\n        this._initializeChildren();\n        if (!this._config.parent) {\n            this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n        }\n        if (this._config.toggle) {\n            this.toggle();\n        }\n    }\n    // Getters\n    static get Default() {\n        return Default$a;\n    }\n    static get DefaultType() {\n        return DefaultType$a;\n    }\n    static get NAME() {\n        return NAME$b;\n    }\n    // Public\n    toggle() {\n        if (this._isShown()) {\n            this.hide();\n        } else {\n            this.show();\n        }\n    }\n    show() {\n        if (this._isTransitioning || this._isShown()) {\n            return;\n        }\n        let activeChildren = [];\n        // find active children\n        if (this._config.parent) {\n            activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element)=>element !== this._element).map((element)=>Collapse.getOrCreateInstance(element, {\n                    toggle: false\n                }));\n        }\n        if (activeChildren.length && activeChildren[0]._isTransitioning) {\n            return;\n        }\n        const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n        if (startEvent.defaultPrevented) {\n            return;\n        }\n        for (const activeInstance of activeChildren){\n            activeInstance.hide();\n        }\n        const dimension = this._getDimension();\n        this._element.classList.remove(CLASS_NAME_COLLAPSE);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.style[dimension] = 0;\n        this._addAriaAndCollapsedClass(this._triggerArray, true);\n        this._isTransitioning = true;\n        const complete = ()=>{\n            this._isTransitioning = false;\n            this._element.classList.remove(CLASS_NAME_COLLAPSING);\n            this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n            this._element.style[dimension] = \"\";\n            EventHandler.trigger(this._element, EVENT_SHOWN$6);\n        };\n        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n        const scrollSize = `scroll${capitalizedDimension}`;\n        this._queueCallback(complete, this._element, true);\n        this._element.style[dimension] = `${this._element[scrollSize]}px`;\n    }\n    hide() {\n        if (this._isTransitioning || !this._isShown()) {\n            return;\n        }\n        const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n        if (startEvent.defaultPrevented) {\n            return;\n        }\n        const dimension = this._getDimension();\n        this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n        for (const trigger of this._triggerArray){\n            const element = SelectorEngine.getElementFromSelector(trigger);\n            if (element && !this._isShown(element)) {\n                this._addAriaAndCollapsedClass([\n                    trigger\n                ], false);\n            }\n        }\n        this._isTransitioning = true;\n        const complete = ()=>{\n            this._isTransitioning = false;\n            this._element.classList.remove(CLASS_NAME_COLLAPSING);\n            this._element.classList.add(CLASS_NAME_COLLAPSE);\n            EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n        };\n        this._element.style[dimension] = \"\";\n        this._queueCallback(complete, this._element, true);\n    }\n    // Private\n    _isShown(element = this._element) {\n        return element.classList.contains(CLASS_NAME_SHOW$7);\n    }\n    _configAfterMerge(config) {\n        config.toggle = Boolean(config.toggle); // Coerce string values\n        config.parent = getElement(config.parent);\n        return config;\n    }\n    _getDimension() {\n        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n    }\n    _initializeChildren() {\n        if (!this._config.parent) {\n            return;\n        }\n        const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n        for (const element of children){\n            const selected = SelectorEngine.getElementFromSelector(element);\n            if (selected) {\n                this._addAriaAndCollapsedClass([\n                    element\n                ], this._isShown(selected));\n            }\n        }\n    }\n    _getFirstLevelChildren(selector) {\n        const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\n        // remove children if greater depth\n        return SelectorEngine.find(selector, this._config.parent).filter((element)=>!children.includes(element));\n    }\n    _addAriaAndCollapsedClass(triggerArray, isOpen) {\n        if (!triggerArray.length) {\n            return;\n        }\n        for (const element of triggerArray){\n            element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n            element.setAttribute(\"aria-expanded\", isOpen);\n        }\n    }\n    // Static\n    static jQueryInterface(config) {\n        const _config = {};\n        if (typeof config === \"string\" && /show|hide/.test(config)) {\n            _config.toggle = false;\n        }\n        return this.each(function() {\n            const data = Collapse.getOrCreateInstance(this, _config);\n            if (typeof config === \"string\") {\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            }\n        });\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.target.tagName === \"A\" || event.delegateTarget && event.delegateTarget.tagName === \"A\") {\n        event.preventDefault();\n    }\n    for (const element of SelectorEngine.getMultipleElementsFromSelector(this)){\n        Collapse.getOrCreateInstance(element, {\n            toggle: false\n        }).toggle();\n    }\n});\n/**\n * jQuery\n */ defineJQueryPlugin(Collapse);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$a = \"dropdown\";\nconst DATA_KEY$6 = \"bs.dropdown\";\nconst EVENT_KEY$6 = `.${DATA_KEY$6}`;\nconst DATA_API_KEY$3 = \".data-api\";\nconst ESCAPE_KEY$2 = \"Escape\";\nconst TAB_KEY$1 = \"Tab\";\nconst ARROW_UP_KEY$1 = \"ArrowUp\";\nconst ARROW_DOWN_KEY$1 = \"ArrowDown\";\nconst RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\nconst EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\nconst EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\nconst EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\nconst EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\nconst EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst CLASS_NAME_SHOW$6 = \"show\";\nconst CLASS_NAME_DROPUP = \"dropup\";\nconst CLASS_NAME_DROPEND = \"dropend\";\nconst CLASS_NAME_DROPSTART = \"dropstart\";\nconst CLASS_NAME_DROPUP_CENTER = \"dropup-center\";\nconst CLASS_NAME_DROPDOWN_CENTER = \"dropdown-center\";\nconst SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\nconst SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\nconst SELECTOR_MENU = \".dropdown-menu\";\nconst SELECTOR_NAVBAR = \".navbar\";\nconst SELECTOR_NAVBAR_NAV = \".navbar-nav\";\nconst SELECTOR_VISIBLE_ITEMS = \".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\";\nconst PLACEMENT_TOP = isRTL() ? \"top-end\" : \"top-start\";\nconst PLACEMENT_TOPEND = isRTL() ? \"top-start\" : \"top-end\";\nconst PLACEMENT_BOTTOM = isRTL() ? \"bottom-end\" : \"bottom-start\";\nconst PLACEMENT_BOTTOMEND = isRTL() ? \"bottom-start\" : \"bottom-end\";\nconst PLACEMENT_RIGHT = isRTL() ? \"left-start\" : \"right-start\";\nconst PLACEMENT_LEFT = isRTL() ? \"right-start\" : \"left-start\";\nconst PLACEMENT_TOPCENTER = \"top\";\nconst PLACEMENT_BOTTOMCENTER = \"bottom\";\nconst Default$9 = {\n    autoClose: true,\n    boundary: \"clippingParents\",\n    display: \"dynamic\",\n    offset: [\n        0,\n        2\n    ],\n    popperConfig: null,\n    reference: \"toggle\"\n};\nconst DefaultType$9 = {\n    autoClose: \"(boolean|string)\",\n    boundary: \"(string|element)\",\n    display: \"string\",\n    offset: \"(array|string|function)\",\n    popperConfig: \"(null|object|function)\",\n    reference: \"(string|element|object)\"\n};\n/**\n * Class definition\n */ class Dropdown extends BaseComponent {\n    constructor(element, config){\n        super(element, config);\n        this._popper = null;\n        this._parent = this._element.parentNode; // dropdown wrapper\n        // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n        this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n        this._inNavbar = this._detectNavbar();\n    }\n    // Getters\n    static get Default() {\n        return Default$9;\n    }\n    static get DefaultType() {\n        return DefaultType$9;\n    }\n    static get NAME() {\n        return NAME$a;\n    }\n    // Public\n    toggle() {\n        return this._isShown() ? this.hide() : this.show();\n    }\n    show() {\n        if (isDisabled(this._element) || this._isShown()) {\n            return;\n        }\n        const relatedTarget = {\n            relatedTarget: this._element\n        };\n        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n        if (showEvent.defaultPrevented) {\n            return;\n        }\n        this._createPopper();\n        // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n        if (\"ontouchstart\" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n            for (const element of [].concat(...document.body.children)){\n                EventHandler.on(element, \"mouseover\", noop);\n            }\n        }\n        this._element.focus();\n        this._element.setAttribute(\"aria-expanded\", true);\n        this._menu.classList.add(CLASS_NAME_SHOW$6);\n        this._element.classList.add(CLASS_NAME_SHOW$6);\n        EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n    }\n    hide() {\n        if (isDisabled(this._element) || !this._isShown()) {\n            return;\n        }\n        const relatedTarget = {\n            relatedTarget: this._element\n        };\n        this._completeHide(relatedTarget);\n    }\n    dispose() {\n        if (this._popper) {\n            this._popper.destroy();\n        }\n        super.dispose();\n    }\n    update() {\n        this._inNavbar = this._detectNavbar();\n        if (this._popper) {\n            this._popper.update();\n        }\n    }\n    // Private\n    _completeHide(relatedTarget) {\n        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n        if (hideEvent.defaultPrevented) {\n            return;\n        }\n        // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n        if (\"ontouchstart\" in document.documentElement) {\n            for (const element of [].concat(...document.body.children)){\n                EventHandler.off(element, \"mouseover\", noop);\n            }\n        }\n        if (this._popper) {\n            this._popper.destroy();\n        }\n        this._menu.classList.remove(CLASS_NAME_SHOW$6);\n        this._element.classList.remove(CLASS_NAME_SHOW$6);\n        this._element.setAttribute(\"aria-expanded\", \"false\");\n        Manipulator.removeDataAttribute(this._menu, \"popper\");\n        EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n        // Explicitly return focus to the trigger element\n        this._element.focus();\n    }\n    _getConfig(config) {\n        config = super._getConfig(config);\n        if (typeof config.reference === \"object\" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== \"function\") {\n            // Popper virtual elements require a getBoundingClientRect method\n            throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n        }\n        return config;\n    }\n    _createPopper() {\n        if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === \"undefined\") {\n            throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)\");\n        }\n        let referenceElement = this._element;\n        if (this._config.reference === \"parent\") {\n            referenceElement = this._parent;\n        } else if (isElement(this._config.reference)) {\n            referenceElement = getElement(this._config.reference);\n        } else if (typeof this._config.reference === \"object\") {\n            referenceElement = this._config.reference;\n        }\n        const popperConfig = this._getPopperConfig();\n        this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(referenceElement, this._menu, popperConfig);\n    }\n    _isShown() {\n        return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n    }\n    _getPlacement() {\n        const parentDropdown = this._parent;\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n            return PLACEMENT_RIGHT;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n            return PLACEMENT_LEFT;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n            return PLACEMENT_TOPCENTER;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n            return PLACEMENT_BOTTOMCENTER;\n        }\n        // We need to trim the value because custom properties can also include spaces\n        const isEnd = getComputedStyle(this._menu).getPropertyValue(\"--bs-position\").trim() === \"end\";\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n            return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n        }\n        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n    }\n    _detectNavbar() {\n        return this._element.closest(SELECTOR_NAVBAR) !== null;\n    }\n    _getOffset() {\n        const { offset } = this._config;\n        if (typeof offset === \"string\") {\n            return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n        }\n        if (typeof offset === \"function\") {\n            return (popperData)=>offset(popperData, this._element);\n        }\n        return offset;\n    }\n    _getPopperConfig() {\n        const defaultBsPopperConfig = {\n            placement: this._getPlacement(),\n            modifiers: [\n                {\n                    name: \"preventOverflow\",\n                    options: {\n                        boundary: this._config.boundary\n                    }\n                },\n                {\n                    name: \"offset\",\n                    options: {\n                        offset: this._getOffset()\n                    }\n                }\n            ]\n        };\n        // Disable Popper if we have a static display or Dropdown is in Navbar\n        if (this._inNavbar || this._config.display === \"static\") {\n            Manipulator.setDataAttribute(this._menu, \"popper\", \"static\"); // TODO: v6 remove\n            defaultBsPopperConfig.modifiers = [\n                {\n                    name: \"applyStyles\",\n                    enabled: false\n                }\n            ];\n        }\n        return {\n            ...defaultBsPopperConfig,\n            ...execute(this._config.popperConfig, [\n                undefined,\n                defaultBsPopperConfig\n            ])\n        };\n    }\n    _selectMenuItem({ key, target }) {\n        const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element)=>isVisible(element));\n        if (!items.length) {\n            return;\n        }\n        // if target isn't included in items (e.g. when expanding the dropdown)\n        // allow cycling to get the last item in case key equals ARROW_UP_KEY\n        getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Dropdown.getOrCreateInstance(this, config);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (typeof data[config] === \"undefined\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config]();\n        });\n    }\n    static clearMenus(event) {\n        if (event.button === RIGHT_MOUSE_BUTTON || event.type === \"keyup\" && event.key !== TAB_KEY$1) {\n            return;\n        }\n        const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n        for (const toggle of openToggles){\n            const context = Dropdown.getInstance(toggle);\n            if (!context || context._config.autoClose === false) {\n                continue;\n            }\n            const composedPath = event.composedPath();\n            const isMenuTarget = composedPath.includes(context._menu);\n            if (composedPath.includes(context._element) || context._config.autoClose === \"inside\" && !isMenuTarget || context._config.autoClose === \"outside\" && isMenuTarget) {\n                continue;\n            }\n            // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n            if (context._menu.contains(event.target) && (event.type === \"keyup\" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n                continue;\n            }\n            const relatedTarget = {\n                relatedTarget: context._element\n            };\n            if (event.type === \"click\") {\n                relatedTarget.clickEvent = event;\n            }\n            context._completeHide(relatedTarget);\n        }\n    }\n    static dataApiKeydownHandler(event) {\n        // If not an UP | DOWN | ESCAPE key => not a dropdown command\n        // If input/textarea && if key is other than ESCAPE => not a dropdown command\n        const isInput = /input|textarea/i.test(event.target.tagName);\n        const isEscapeEvent = event.key === ESCAPE_KEY$2;\n        const isUpOrDownEvent = [\n            ARROW_UP_KEY$1,\n            ARROW_DOWN_KEY$1\n        ].includes(event.key);\n        if (!isUpOrDownEvent && !isEscapeEvent) {\n            return;\n        }\n        if (isInput && !isEscapeEvent) {\n            return;\n        }\n        event.preventDefault();\n        // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n        const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n        const instance = Dropdown.getOrCreateInstance(getToggleButton);\n        if (isUpOrDownEvent) {\n            event.stopPropagation();\n            instance.show();\n            instance._selectMenuItem(event);\n            return;\n        }\n        if (instance._isShown()) {\n            // else is escape and we check if it is shown\n            event.stopPropagation();\n            instance.hide();\n            getToggleButton.focus();\n        }\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {\n    event.preventDefault();\n    Dropdown.getOrCreateInstance(this).toggle();\n});\n/**\n * jQuery\n */ defineJQueryPlugin(Dropdown);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/backdrop.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$9 = \"backdrop\";\nconst CLASS_NAME_FADE$4 = \"fade\";\nconst CLASS_NAME_SHOW$5 = \"show\";\nconst EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\nconst Default$8 = {\n    className: \"modal-backdrop\",\n    clickCallback: null,\n    isAnimated: false,\n    isVisible: true,\n    // if false, we use the backdrop helper without adding any element to the dom\n    rootElement: \"body\" // give the choice to place backdrop under different elements\n};\nconst DefaultType$8 = {\n    className: \"string\",\n    clickCallback: \"(function|null)\",\n    isAnimated: \"boolean\",\n    isVisible: \"boolean\",\n    rootElement: \"(element|string)\"\n};\n/**\n * Class definition\n */ class Backdrop extends Config {\n    constructor(config){\n        super();\n        this._config = this._getConfig(config);\n        this._isAppended = false;\n        this._element = null;\n    }\n    // Getters\n    static get Default() {\n        return Default$8;\n    }\n    static get DefaultType() {\n        return DefaultType$8;\n    }\n    static get NAME() {\n        return NAME$9;\n    }\n    // Public\n    show(callback) {\n        if (!this._config.isVisible) {\n            execute(callback);\n            return;\n        }\n        this._append();\n        const element = this._getElement();\n        if (this._config.isAnimated) {\n            reflow(element);\n        }\n        element.classList.add(CLASS_NAME_SHOW$5);\n        this._emulateAnimation(()=>{\n            execute(callback);\n        });\n    }\n    hide(callback) {\n        if (!this._config.isVisible) {\n            execute(callback);\n            return;\n        }\n        this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n        this._emulateAnimation(()=>{\n            this.dispose();\n            execute(callback);\n        });\n    }\n    dispose() {\n        if (!this._isAppended) {\n            return;\n        }\n        EventHandler.off(this._element, EVENT_MOUSEDOWN);\n        this._element.remove();\n        this._isAppended = false;\n    }\n    // Private\n    _getElement() {\n        if (!this._element) {\n            const backdrop = document.createElement(\"div\");\n            backdrop.className = this._config.className;\n            if (this._config.isAnimated) {\n                backdrop.classList.add(CLASS_NAME_FADE$4);\n            }\n            this._element = backdrop;\n        }\n        return this._element;\n    }\n    _configAfterMerge(config) {\n        // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n        config.rootElement = getElement(config.rootElement);\n        return config;\n    }\n    _append() {\n        if (this._isAppended) {\n            return;\n        }\n        const element = this._getElement();\n        this._config.rootElement.append(element);\n        EventHandler.on(element, EVENT_MOUSEDOWN, ()=>{\n            execute(this._config.clickCallback);\n        });\n        this._isAppended = true;\n    }\n    _emulateAnimation(callback) {\n        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n    }\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/focustrap.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$8 = \"focustrap\";\nconst DATA_KEY$5 = \"bs.focustrap\";\nconst EVENT_KEY$5 = `.${DATA_KEY$5}`;\nconst EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\nconst EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\nconst TAB_KEY = \"Tab\";\nconst TAB_NAV_FORWARD = \"forward\";\nconst TAB_NAV_BACKWARD = \"backward\";\nconst Default$7 = {\n    autofocus: true,\n    trapElement: null // The element to trap focus inside of\n};\nconst DefaultType$7 = {\n    autofocus: \"boolean\",\n    trapElement: \"element\"\n};\n/**\n * Class definition\n */ class FocusTrap extends Config {\n    constructor(config){\n        super();\n        this._config = this._getConfig(config);\n        this._isActive = false;\n        this._lastTabNavDirection = null;\n    }\n    // Getters\n    static get Default() {\n        return Default$7;\n    }\n    static get DefaultType() {\n        return DefaultType$7;\n    }\n    static get NAME() {\n        return NAME$8;\n    }\n    // Public\n    activate() {\n        if (this._isActive) {\n            return;\n        }\n        if (this._config.autofocus) {\n            this._config.trapElement.focus();\n        }\n        EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n        EventHandler.on(document, EVENT_FOCUSIN$2, (event)=>this._handleFocusin(event));\n        EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event));\n        this._isActive = true;\n    }\n    deactivate() {\n        if (!this._isActive) {\n            return;\n        }\n        this._isActive = false;\n        EventHandler.off(document, EVENT_KEY$5);\n    }\n    // Private\n    _handleFocusin(event) {\n        const { trapElement } = this._config;\n        if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n            return;\n        }\n        const elements = SelectorEngine.focusableChildren(trapElement);\n        if (elements.length === 0) {\n            trapElement.focus();\n        } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n            elements[elements.length - 1].focus();\n        } else {\n            elements[0].focus();\n        }\n    }\n    _handleKeydown(event) {\n        if (event.key !== TAB_KEY) {\n            return;\n        }\n        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n    }\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const SELECTOR_FIXED_CONTENT = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\";\nconst SELECTOR_STICKY_CONTENT = \".sticky-top\";\nconst PROPERTY_PADDING = \"padding-right\";\nconst PROPERTY_MARGIN = \"margin-right\";\n/**\n * Class definition\n */ class ScrollBarHelper {\n    constructor(){\n        this._element = document.body;\n    }\n    // Public\n    getWidth() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n        const documentWidth = document.documentElement.clientWidth;\n        return Math.abs(window.innerWidth - documentWidth);\n    }\n    hide() {\n        const width = this.getWidth();\n        this._disableOverFlow();\n        // give padding to element to balance the hidden scrollbar width\n        this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n        // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n        this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n        this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue)=>calculatedValue - width);\n    }\n    reset() {\n        this._resetElementAttributes(this._element, \"overflow\");\n        this._resetElementAttributes(this._element, PROPERTY_PADDING);\n        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n    }\n    isOverflowing() {\n        return this.getWidth() > 0;\n    }\n    // Private\n    _disableOverFlow() {\n        this._saveInitialAttribute(this._element, \"overflow\");\n        this._element.style.overflow = \"hidden\";\n    }\n    _setElementAttributes(selector, styleProperty, callback) {\n        const scrollbarWidth = this.getWidth();\n        const manipulationCallBack = (element)=>{\n            if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n                return;\n            }\n            this._saveInitialAttribute(element, styleProperty);\n            const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n            element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n    _saveInitialAttribute(element, styleProperty) {\n        const actualValue = element.style.getPropertyValue(styleProperty);\n        if (actualValue) {\n            Manipulator.setDataAttribute(element, styleProperty, actualValue);\n        }\n    }\n    _resetElementAttributes(selector, styleProperty) {\n        const manipulationCallBack = (element)=>{\n            const value = Manipulator.getDataAttribute(element, styleProperty);\n            // We only want to remove the property if the value is `null`; the value can also be zero\n            if (value === null) {\n                element.style.removeProperty(styleProperty);\n                return;\n            }\n            Manipulator.removeDataAttribute(element, styleProperty);\n            element.style.setProperty(styleProperty, value);\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n    _applyManipulationCallback(selector, callBack) {\n        if (isElement(selector)) {\n            callBack(selector);\n            return;\n        }\n        for (const sel of SelectorEngine.find(selector, this._element)){\n            callBack(sel);\n        }\n    }\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$7 = \"modal\";\nconst DATA_KEY$4 = \"bs.modal\";\nconst EVENT_KEY$4 = `.${DATA_KEY$4}`;\nconst DATA_API_KEY$2 = \".data-api\";\nconst ESCAPE_KEY$1 = \"Escape\";\nconst EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\nconst EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\nconst EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\nconst EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\nconst EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\nconst EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\nconst EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\nconst EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\nconst CLASS_NAME_OPEN = \"modal-open\";\nconst CLASS_NAME_FADE$3 = \"fade\";\nconst CLASS_NAME_SHOW$4 = \"show\";\nconst CLASS_NAME_STATIC = \"modal-static\";\nconst OPEN_SELECTOR$1 = \".modal.show\";\nconst SELECTOR_DIALOG = \".modal-dialog\";\nconst SELECTOR_MODAL_BODY = \".modal-body\";\nconst SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\nconst Default$6 = {\n    backdrop: true,\n    focus: true,\n    keyboard: true\n};\nconst DefaultType$6 = {\n    backdrop: \"(boolean|string)\",\n    focus: \"boolean\",\n    keyboard: \"boolean\"\n};\n/**\n * Class definition\n */ class Modal extends BaseComponent {\n    constructor(element, config){\n        super(element, config);\n        this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n        this._backdrop = this._initializeBackDrop();\n        this._focustrap = this._initializeFocusTrap();\n        this._isShown = false;\n        this._isTransitioning = false;\n        this._scrollBar = new ScrollBarHelper();\n        this._addEventListeners();\n    }\n    // Getters\n    static get Default() {\n        return Default$6;\n    }\n    static get DefaultType() {\n        return DefaultType$6;\n    }\n    static get NAME() {\n        return NAME$7;\n    }\n    // Public\n    toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n    }\n    show(relatedTarget) {\n        if (this._isShown || this._isTransitioning) {\n            return;\n        }\n        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n            relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n            return;\n        }\n        this._isShown = true;\n        this._isTransitioning = true;\n        this._scrollBar.hide();\n        document.body.classList.add(CLASS_NAME_OPEN);\n        this._adjustDialog();\n        this._backdrop.show(()=>this._showElement(relatedTarget));\n    }\n    hide() {\n        if (!this._isShown || this._isTransitioning) {\n            return;\n        }\n        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n        if (hideEvent.defaultPrevented) {\n            return;\n        }\n        this._isShown = false;\n        this._isTransitioning = true;\n        this._focustrap.deactivate();\n        this._element.classList.remove(CLASS_NAME_SHOW$4);\n        this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated());\n    }\n    dispose() {\n        EventHandler.off(window, EVENT_KEY$4);\n        EventHandler.off(this._dialog, EVENT_KEY$4);\n        this._backdrop.dispose();\n        this._focustrap.deactivate();\n        super.dispose();\n    }\n    handleUpdate() {\n        this._adjustDialog();\n    }\n    // Private\n    _initializeBackDrop() {\n        return new Backdrop({\n            isVisible: Boolean(this._config.backdrop),\n            // 'static' option will be translated to true, and booleans will keep their value,\n            isAnimated: this._isAnimated()\n        });\n    }\n    _initializeFocusTrap() {\n        return new FocusTrap({\n            trapElement: this._element\n        });\n    }\n    _showElement(relatedTarget) {\n        // try to append dynamic modal\n        if (!document.body.contains(this._element)) {\n            document.body.append(this._element);\n        }\n        this._element.style.display = \"block\";\n        this._element.removeAttribute(\"aria-hidden\");\n        this._element.setAttribute(\"aria-modal\", true);\n        this._element.setAttribute(\"role\", \"dialog\");\n        this._element.scrollTop = 0;\n        const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n        if (modalBody) {\n            modalBody.scrollTop = 0;\n        }\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_SHOW$4);\n        const transitionComplete = ()=>{\n            if (this._config.focus) {\n                this._focustrap.activate();\n            }\n            this._isTransitioning = false;\n            EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n                relatedTarget\n            });\n        };\n        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n    }\n    _addEventListeners() {\n        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{\n            if (event.key !== ESCAPE_KEY$1) {\n                return;\n            }\n            if (this._config.keyboard) {\n                this.hide();\n                return;\n            }\n            this._triggerBackdropTransition();\n        });\n        EventHandler.on(window, EVENT_RESIZE$1, ()=>{\n            if (this._isShown && !this._isTransitioning) {\n                this._adjustDialog();\n            }\n        });\n        EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event)=>{\n            // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n            EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2)=>{\n                if (this._element !== event.target || this._element !== event2.target) {\n                    return;\n                }\n                if (this._config.backdrop === \"static\") {\n                    this._triggerBackdropTransition();\n                    return;\n                }\n                if (this._config.backdrop) {\n                    this.hide();\n                }\n            });\n        });\n    }\n    _hideModal() {\n        this._element.style.display = \"none\";\n        this._element.setAttribute(\"aria-hidden\", true);\n        this._element.removeAttribute(\"aria-modal\");\n        this._element.removeAttribute(\"role\");\n        this._isTransitioning = false;\n        this._backdrop.hide(()=>{\n            document.body.classList.remove(CLASS_NAME_OPEN);\n            this._resetAdjustments();\n            this._scrollBar.reset();\n            EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n        });\n    }\n    _isAnimated() {\n        return this._element.classList.contains(CLASS_NAME_FADE$3);\n    }\n    _triggerBackdropTransition() {\n        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n        if (hideEvent.defaultPrevented) {\n            return;\n        }\n        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n        const initialOverflowY = this._element.style.overflowY;\n        // return if the following background transition hasn't yet completed\n        if (initialOverflowY === \"hidden\" || this._element.classList.contains(CLASS_NAME_STATIC)) {\n            return;\n        }\n        if (!isModalOverflowing) {\n            this._element.style.overflowY = \"hidden\";\n        }\n        this._element.classList.add(CLASS_NAME_STATIC);\n        this._queueCallback(()=>{\n            this._element.classList.remove(CLASS_NAME_STATIC);\n            this._queueCallback(()=>{\n                this._element.style.overflowY = initialOverflowY;\n            }, this._dialog);\n        }, this._dialog);\n        this._element.focus();\n    }\n    /**\n   * The following methods are used to handle overflowing modals\n   */ _adjustDialog() {\n        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n        const scrollbarWidth = this._scrollBar.getWidth();\n        const isBodyOverflowing = scrollbarWidth > 0;\n        if (isBodyOverflowing && !isModalOverflowing) {\n            const property = isRTL() ? \"paddingLeft\" : \"paddingRight\";\n            this._element.style[property] = `${scrollbarWidth}px`;\n        }\n        if (!isBodyOverflowing && isModalOverflowing) {\n            const property = isRTL() ? \"paddingRight\" : \"paddingLeft\";\n            this._element.style[property] = `${scrollbarWidth}px`;\n        }\n    }\n    _resetAdjustments() {\n        this._element.style.paddingLeft = \"\";\n        this._element.style.paddingRight = \"\";\n    }\n    // Static\n    static jQueryInterface(config, relatedTarget) {\n        return this.each(function() {\n            const data = Modal.getOrCreateInstance(this, config);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (typeof data[config] === \"undefined\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config](relatedTarget);\n        });\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {\n    const target = SelectorEngine.getElementFromSelector(this);\n    if ([\n        \"A\",\n        \"AREA\"\n    ].includes(this.tagName)) {\n        event.preventDefault();\n    }\n    EventHandler.one(target, EVENT_SHOW$4, (showEvent)=>{\n        if (showEvent.defaultPrevented) {\n            // only register focus restorer if modal will actually get shown\n            return;\n        }\n        EventHandler.one(target, EVENT_HIDDEN$4, ()=>{\n            if (isVisible(this)) {\n                this.focus();\n            }\n        });\n    });\n    // avoid conflict when clicking modal toggler while another one is open\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n    if (alreadyOpen) {\n        Modal.getInstance(alreadyOpen).hide();\n    }\n    const data = Modal.getOrCreateInstance(target);\n    data.toggle(this);\n});\nenableDismissTrigger(Modal);\n/**\n * jQuery\n */ defineJQueryPlugin(Modal);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap offcanvas.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$6 = \"offcanvas\";\nconst DATA_KEY$3 = \"bs.offcanvas\";\nconst EVENT_KEY$3 = `.${DATA_KEY$3}`;\nconst DATA_API_KEY$1 = \".data-api\";\nconst EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\nconst ESCAPE_KEY = \"Escape\";\nconst CLASS_NAME_SHOW$3 = \"show\";\nconst CLASS_NAME_SHOWING$1 = \"showing\";\nconst CLASS_NAME_HIDING = \"hiding\";\nconst CLASS_NAME_BACKDROP = \"offcanvas-backdrop\";\nconst OPEN_SELECTOR = \".offcanvas.show\";\nconst EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\nconst EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\nconst EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\nconst EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\nconst EVENT_RESIZE = `resize${EVENT_KEY$3}`;\nconst EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\nconst SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\nconst Default$5 = {\n    backdrop: true,\n    keyboard: true,\n    scroll: false\n};\nconst DefaultType$5 = {\n    backdrop: \"(boolean|string)\",\n    keyboard: \"boolean\",\n    scroll: \"boolean\"\n};\n/**\n * Class definition\n */ class Offcanvas extends BaseComponent {\n    constructor(element, config){\n        super(element, config);\n        this._isShown = false;\n        this._backdrop = this._initializeBackDrop();\n        this._focustrap = this._initializeFocusTrap();\n        this._addEventListeners();\n    }\n    // Getters\n    static get Default() {\n        return Default$5;\n    }\n    static get DefaultType() {\n        return DefaultType$5;\n    }\n    static get NAME() {\n        return NAME$6;\n    }\n    // Public\n    toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n    }\n    show(relatedTarget) {\n        if (this._isShown) {\n            return;\n        }\n        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n            relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n            return;\n        }\n        this._isShown = true;\n        this._backdrop.show();\n        if (!this._config.scroll) {\n            new ScrollBarHelper().hide();\n        }\n        this._element.setAttribute(\"aria-modal\", true);\n        this._element.setAttribute(\"role\", \"dialog\");\n        this._element.classList.add(CLASS_NAME_SHOWING$1);\n        const completeCallBack = ()=>{\n            if (!this._config.scroll || this._config.backdrop) {\n                this._focustrap.activate();\n            }\n            this._element.classList.add(CLASS_NAME_SHOW$3);\n            this._element.classList.remove(CLASS_NAME_SHOWING$1);\n            EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n                relatedTarget\n            });\n        };\n        this._queueCallback(completeCallBack, this._element, true);\n    }\n    hide() {\n        if (!this._isShown) {\n            return;\n        }\n        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n        if (hideEvent.defaultPrevented) {\n            return;\n        }\n        this._focustrap.deactivate();\n        this._element.blur();\n        this._isShown = false;\n        this._element.classList.add(CLASS_NAME_HIDING);\n        this._backdrop.hide();\n        const completeCallback = ()=>{\n            this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n            this._element.removeAttribute(\"aria-modal\");\n            this._element.removeAttribute(\"role\");\n            if (!this._config.scroll) {\n                new ScrollBarHelper().reset();\n            }\n            EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n        };\n        this._queueCallback(completeCallback, this._element, true);\n    }\n    dispose() {\n        this._backdrop.dispose();\n        this._focustrap.deactivate();\n        super.dispose();\n    }\n    // Private\n    _initializeBackDrop() {\n        const clickCallback = ()=>{\n            if (this._config.backdrop === \"static\") {\n                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n                return;\n            }\n            this.hide();\n        };\n        // 'static' option will be translated to true, and booleans will keep their value\n        const isVisible = Boolean(this._config.backdrop);\n        return new Backdrop({\n            className: CLASS_NAME_BACKDROP,\n            isVisible,\n            isAnimated: true,\n            rootElement: this._element.parentNode,\n            clickCallback: isVisible ? clickCallback : null\n        });\n    }\n    _initializeFocusTrap() {\n        return new FocusTrap({\n            trapElement: this._element\n        });\n    }\n    _addEventListeners() {\n        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{\n            if (event.key !== ESCAPE_KEY) {\n                return;\n            }\n            if (this._config.keyboard) {\n                this.hide();\n                return;\n            }\n            EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n        });\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Offcanvas.getOrCreateInstance(this, config);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config](this);\n        });\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {\n    const target = SelectorEngine.getElementFromSelector(this);\n    if ([\n        \"A\",\n        \"AREA\"\n    ].includes(this.tagName)) {\n        event.preventDefault();\n    }\n    if (isDisabled(this)) {\n        return;\n    }\n    EventHandler.one(target, EVENT_HIDDEN$3, ()=>{\n        // focus on trigger when it is closed\n        if (isVisible(this)) {\n            this.focus();\n        }\n    });\n    // avoid conflict when clicking a toggler of an offcanvas, while another is open\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n    if (alreadyOpen && alreadyOpen !== target) {\n        Offcanvas.getInstance(alreadyOpen).hide();\n    }\n    const data = Offcanvas.getOrCreateInstance(target);\n    data.toggle(this);\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{\n    for (const selector of SelectorEngine.find(OPEN_SELECTOR)){\n        Offcanvas.getOrCreateInstance(selector).show();\n    }\n});\nEventHandler.on(window, EVENT_RESIZE, ()=>{\n    for (const element of SelectorEngine.find(\"[aria-modal][class*=show][class*=offcanvas-]\")){\n        if (getComputedStyle(element).position !== \"fixed\") {\n            Offcanvas.getOrCreateInstance(element).hide();\n        }\n    }\n});\nenableDismissTrigger(Offcanvas);\n/**\n * jQuery\n */ defineJQueryPlugin(Offcanvas);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ // js-docs-start allow-list\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\nconst DefaultAllowlist = {\n    // Global attributes allowed on any supplied element below.\n    \"*\": [\n        \"class\",\n        \"dir\",\n        \"id\",\n        \"lang\",\n        \"role\",\n        ARIA_ATTRIBUTE_PATTERN\n    ],\n    a: [\n        \"target\",\n        \"href\",\n        \"title\",\n        \"rel\"\n    ],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    dd: [],\n    div: [],\n    dl: [],\n    dt: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: [\n        \"src\",\n        \"srcset\",\n        \"alt\",\n        \"title\",\n        \"width\",\n        \"height\"\n    ],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n};\n// js-docs-end allow-list\nconst uriAttributes = new Set([\n    \"background\",\n    \"cite\",\n    \"href\",\n    \"itemtype\",\n    \"longdesc\",\n    \"poster\",\n    \"src\",\n    \"xlink:href\"\n]);\n/**\n * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n * contexts.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\n */ // eslint-disable-next-line unicorn/better-regex\nconst SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\nconst allowedAttribute = (attribute, allowedAttributeList)=>{\n    const attributeName = attribute.nodeName.toLowerCase();\n    if (allowedAttributeList.includes(attributeName)) {\n        if (uriAttributes.has(attributeName)) {\n            return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\n        }\n        return true;\n    }\n    // Check if a regular expression validates the attribute.\n    return allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp).some((regex)=>regex.test(attributeName));\n};\nfunction sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n    if (!unsafeHtml.length) {\n        return unsafeHtml;\n    }\n    if (sanitizeFunction && typeof sanitizeFunction === \"function\") {\n        return sanitizeFunction(unsafeHtml);\n    }\n    const domParser = new window.DOMParser();\n    const createdDocument = domParser.parseFromString(unsafeHtml, \"text/html\");\n    const elements = [].concat(...createdDocument.body.querySelectorAll(\"*\"));\n    for (const element of elements){\n        const elementName = element.nodeName.toLowerCase();\n        if (!Object.keys(allowList).includes(elementName)) {\n            element.remove();\n            continue;\n        }\n        const attributeList = [].concat(...element.attributes);\n        const allowedAttributes = [].concat(allowList[\"*\"] || [], allowList[elementName] || []);\n        for (const attribute of attributeList){\n            if (!allowedAttribute(attribute, allowedAttributes)) {\n                element.removeAttribute(attribute.nodeName);\n            }\n        }\n    }\n    return createdDocument.body.innerHTML;\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/template-factory.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$5 = \"TemplateFactory\";\nconst Default$4 = {\n    allowList: DefaultAllowlist,\n    content: {},\n    // { selector : text ,  selector2 : text2 , }\n    extraClass: \"\",\n    html: false,\n    sanitize: true,\n    sanitizeFn: null,\n    template: \"<div></div>\"\n};\nconst DefaultType$4 = {\n    allowList: \"object\",\n    content: \"object\",\n    extraClass: \"(string|function)\",\n    html: \"boolean\",\n    sanitize: \"boolean\",\n    sanitizeFn: \"(null|function)\",\n    template: \"string\"\n};\nconst DefaultContentType = {\n    entry: \"(string|element|function|null)\",\n    selector: \"(string|element)\"\n};\n/**\n * Class definition\n */ class TemplateFactory extends Config {\n    constructor(config){\n        super();\n        this._config = this._getConfig(config);\n    }\n    // Getters\n    static get Default() {\n        return Default$4;\n    }\n    static get DefaultType() {\n        return DefaultType$4;\n    }\n    static get NAME() {\n        return NAME$5;\n    }\n    // Public\n    getContent() {\n        return Object.values(this._config.content).map((config)=>this._resolvePossibleFunction(config)).filter(Boolean);\n    }\n    hasContent() {\n        return this.getContent().length > 0;\n    }\n    changeContent(content) {\n        this._checkContent(content);\n        this._config.content = {\n            ...this._config.content,\n            ...content\n        };\n        return this;\n    }\n    toHtml() {\n        const templateWrapper = document.createElement(\"div\");\n        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n        for (const [selector, text] of Object.entries(this._config.content)){\n            this._setContent(templateWrapper, text, selector);\n        }\n        const template = templateWrapper.children[0];\n        const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n        if (extraClass) {\n            template.classList.add(...extraClass.split(\" \"));\n        }\n        return template;\n    }\n    // Private\n    _typeCheckConfig(config) {\n        super._typeCheckConfig(config);\n        this._checkContent(config.content);\n    }\n    _checkContent(arg) {\n        for (const [selector, content] of Object.entries(arg)){\n            super._typeCheckConfig({\n                selector,\n                entry: content\n            }, DefaultContentType);\n        }\n    }\n    _setContent(template, content, selector) {\n        const templateElement = SelectorEngine.findOne(selector, template);\n        if (!templateElement) {\n            return;\n        }\n        content = this._resolvePossibleFunction(content);\n        if (!content) {\n            templateElement.remove();\n            return;\n        }\n        if (isElement(content)) {\n            this._putElementInTemplate(getElement(content), templateElement);\n            return;\n        }\n        if (this._config.html) {\n            templateElement.innerHTML = this._maybeSanitize(content);\n            return;\n        }\n        templateElement.textContent = content;\n    }\n    _maybeSanitize(arg) {\n        return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n    }\n    _resolvePossibleFunction(arg) {\n        return execute(arg, [\n            undefined,\n            this\n        ]);\n    }\n    _putElementInTemplate(element, templateElement) {\n        if (this._config.html) {\n            templateElement.innerHTML = \"\";\n            templateElement.append(element);\n            return;\n        }\n        templateElement.textContent = element.textContent;\n    }\n}\n/**\n * --------------------------------------------------------------------------\n * Bootstrap tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$4 = \"tooltip\";\nconst DISALLOWED_ATTRIBUTES = new Set([\n    \"sanitize\",\n    \"allowList\",\n    \"sanitizeFn\"\n]);\nconst CLASS_NAME_FADE$2 = \"fade\";\nconst CLASS_NAME_MODAL = \"modal\";\nconst CLASS_NAME_SHOW$2 = \"show\";\nconst SELECTOR_TOOLTIP_INNER = \".tooltip-inner\";\nconst SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\nconst EVENT_MODAL_HIDE = \"hide.bs.modal\";\nconst TRIGGER_HOVER = \"hover\";\nconst TRIGGER_FOCUS = \"focus\";\nconst TRIGGER_CLICK = \"click\";\nconst TRIGGER_MANUAL = \"manual\";\nconst EVENT_HIDE$2 = \"hide\";\nconst EVENT_HIDDEN$2 = \"hidden\";\nconst EVENT_SHOW$2 = \"show\";\nconst EVENT_SHOWN$2 = \"shown\";\nconst EVENT_INSERTED = \"inserted\";\nconst EVENT_CLICK$1 = \"click\";\nconst EVENT_FOCUSIN$1 = \"focusin\";\nconst EVENT_FOCUSOUT$1 = \"focusout\";\nconst EVENT_MOUSEENTER = \"mouseenter\";\nconst EVENT_MOUSELEAVE = \"mouseleave\";\nconst AttachmentMap = {\n    AUTO: \"auto\",\n    TOP: \"top\",\n    RIGHT: isRTL() ? \"left\" : \"right\",\n    BOTTOM: \"bottom\",\n    LEFT: isRTL() ? \"right\" : \"left\"\n};\nconst Default$3 = {\n    allowList: DefaultAllowlist,\n    animation: true,\n    boundary: \"clippingParents\",\n    container: false,\n    customClass: \"\",\n    delay: 0,\n    fallbackPlacements: [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ],\n    html: false,\n    offset: [\n        0,\n        6\n    ],\n    placement: \"top\",\n    popperConfig: null,\n    sanitize: true,\n    sanitizeFn: null,\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + \"</div>\",\n    title: \"\",\n    trigger: \"hover focus\"\n};\nconst DefaultType$3 = {\n    allowList: \"object\",\n    animation: \"boolean\",\n    boundary: \"(string|element)\",\n    container: \"(string|element|boolean)\",\n    customClass: \"(string|function)\",\n    delay: \"(number|object)\",\n    fallbackPlacements: \"array\",\n    html: \"boolean\",\n    offset: \"(array|string|function)\",\n    placement: \"(string|function)\",\n    popperConfig: \"(null|object|function)\",\n    sanitize: \"boolean\",\n    sanitizeFn: \"(null|function)\",\n    selector: \"(string|boolean)\",\n    template: \"string\",\n    title: \"(string|element|function)\",\n    trigger: \"string\"\n};\n/**\n * Class definition\n */ class Tooltip extends BaseComponent {\n    constructor(element, config){\n        if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === \"undefined\") {\n            throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)\");\n        }\n        super(element, config);\n        // Private\n        this._isEnabled = true;\n        this._timeout = 0;\n        this._isHovered = null;\n        this._activeTrigger = {};\n        this._popper = null;\n        this._templateFactory = null;\n        this._newContent = null;\n        // Protected\n        this.tip = null;\n        this._setListeners();\n        if (!this._config.selector) {\n            this._fixTitle();\n        }\n    }\n    // Getters\n    static get Default() {\n        return Default$3;\n    }\n    static get DefaultType() {\n        return DefaultType$3;\n    }\n    static get NAME() {\n        return NAME$4;\n    }\n    // Public\n    enable() {\n        this._isEnabled = true;\n    }\n    disable() {\n        this._isEnabled = false;\n    }\n    toggleEnabled() {\n        this._isEnabled = !this._isEnabled;\n    }\n    toggle() {\n        if (!this._isEnabled) {\n            return;\n        }\n        if (this._isShown()) {\n            this._leave();\n            return;\n        }\n        this._enter();\n    }\n    dispose() {\n        clearTimeout(this._timeout);\n        EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n        if (this._element.getAttribute(\"data-bs-original-title\")) {\n            this._element.setAttribute(\"title\", this._element.getAttribute(\"data-bs-original-title\"));\n        }\n        this._disposePopper();\n        super.dispose();\n    }\n    show() {\n        if (this._element.style.display === \"none\") {\n            throw new Error(\"Please use show on visible elements\");\n        }\n        if (!(this._isWithContent() && this._isEnabled)) {\n            return;\n        }\n        const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n        const shadowRoot = findShadowRoot(this._element);\n        const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n        if (showEvent.defaultPrevented || !isInTheDom) {\n            return;\n        }\n        // TODO: v6 remove this or make it optional\n        this._disposePopper();\n        const tip = this._getTipElement();\n        this._element.setAttribute(\"aria-describedby\", tip.getAttribute(\"id\"));\n        const { container } = this._config;\n        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n            container.append(tip);\n            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n        }\n        this._popper = this._createPopper(tip);\n        tip.classList.add(CLASS_NAME_SHOW$2);\n        // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n        if (\"ontouchstart\" in document.documentElement) {\n            for (const element of [].concat(...document.body.children)){\n                EventHandler.on(element, \"mouseover\", noop);\n            }\n        }\n        const complete = ()=>{\n            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n            if (this._isHovered === false) {\n                this._leave();\n            }\n            this._isHovered = false;\n        };\n        this._queueCallback(complete, this.tip, this._isAnimated());\n    }\n    hide() {\n        if (!this._isShown()) {\n            return;\n        }\n        const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n        if (hideEvent.defaultPrevented) {\n            return;\n        }\n        const tip = this._getTipElement();\n        tip.classList.remove(CLASS_NAME_SHOW$2);\n        // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n        if (\"ontouchstart\" in document.documentElement) {\n            for (const element of [].concat(...document.body.children)){\n                EventHandler.off(element, \"mouseover\", noop);\n            }\n        }\n        this._activeTrigger[TRIGGER_CLICK] = false;\n        this._activeTrigger[TRIGGER_FOCUS] = false;\n        this._activeTrigger[TRIGGER_HOVER] = false;\n        this._isHovered = null; // it is a trick to support manual triggering\n        const complete = ()=>{\n            if (this._isWithActiveTrigger()) {\n                return;\n            }\n            if (!this._isHovered) {\n                this._disposePopper();\n            }\n            this._element.removeAttribute(\"aria-describedby\");\n            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n        };\n        this._queueCallback(complete, this.tip, this._isAnimated());\n    }\n    update() {\n        if (this._popper) {\n            this._popper.update();\n        }\n    }\n    // Protected\n    _isWithContent() {\n        return Boolean(this._getTitle());\n    }\n    _getTipElement() {\n        if (!this.tip) {\n            this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n        }\n        return this.tip;\n    }\n    _createTipElement(content) {\n        const tip = this._getTemplateFactory(content).toHtml();\n        // TODO: remove this check in v6\n        if (!tip) {\n            return null;\n        }\n        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n        // TODO: v6 the following can be achieved with CSS only\n        tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n        const tipId = getUID(this.constructor.NAME).toString();\n        tip.setAttribute(\"id\", tipId);\n        if (this._isAnimated()) {\n            tip.classList.add(CLASS_NAME_FADE$2);\n        }\n        return tip;\n    }\n    setContent(content) {\n        this._newContent = content;\n        if (this._isShown()) {\n            this._disposePopper();\n            this.show();\n        }\n    }\n    _getTemplateFactory(content) {\n        if (this._templateFactory) {\n            this._templateFactory.changeContent(content);\n        } else {\n            this._templateFactory = new TemplateFactory({\n                ...this._config,\n                // the `content` var has to be after `this._config`\n                // to override config.content in case of popover\n                content,\n                extraClass: this._resolvePossibleFunction(this._config.customClass)\n            });\n        }\n        return this._templateFactory;\n    }\n    _getContentForTemplate() {\n        return {\n            [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n        };\n    }\n    _getTitle() {\n        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute(\"data-bs-original-title\");\n    }\n    // Private\n    _initializeOnDelegatedTarget(event) {\n        return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n    }\n    _isAnimated() {\n        return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n    }\n    _isShown() {\n        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n    }\n    _createPopper(tip) {\n        const placement = execute(this._config.placement, [\n            this,\n            tip,\n            this._element\n        ]);\n        const attachment = AttachmentMap[placement.toUpperCase()];\n        return _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(this._element, tip, this._getPopperConfig(attachment));\n    }\n    _getOffset() {\n        const { offset } = this._config;\n        if (typeof offset === \"string\") {\n            return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n        }\n        if (typeof offset === \"function\") {\n            return (popperData)=>offset(popperData, this._element);\n        }\n        return offset;\n    }\n    _resolvePossibleFunction(arg) {\n        return execute(arg, [\n            this._element,\n            this._element\n        ]);\n    }\n    _getPopperConfig(attachment) {\n        const defaultBsPopperConfig = {\n            placement: attachment,\n            modifiers: [\n                {\n                    name: \"flip\",\n                    options: {\n                        fallbackPlacements: this._config.fallbackPlacements\n                    }\n                },\n                {\n                    name: \"offset\",\n                    options: {\n                        offset: this._getOffset()\n                    }\n                },\n                {\n                    name: \"preventOverflow\",\n                    options: {\n                        boundary: this._config.boundary\n                    }\n                },\n                {\n                    name: \"arrow\",\n                    options: {\n                        element: `.${this.constructor.NAME}-arrow`\n                    }\n                },\n                {\n                    name: \"preSetPlacement\",\n                    enabled: true,\n                    phase: \"beforeMain\",\n                    fn: (data)=>{\n                        // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n                        // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n                        this._getTipElement().setAttribute(\"data-popper-placement\", data.state.placement);\n                    }\n                }\n            ]\n        };\n        return {\n            ...defaultBsPopperConfig,\n            ...execute(this._config.popperConfig, [\n                undefined,\n                defaultBsPopperConfig\n            ])\n        };\n    }\n    _setListeners() {\n        const triggers = this._config.trigger.split(\" \");\n        for (const trigger of triggers){\n            if (trigger === \"click\") {\n                EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event)=>{\n                    const context = this._initializeOnDelegatedTarget(event);\n                    context.toggle();\n                });\n            } else if (trigger !== TRIGGER_MANUAL) {\n                const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n                const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n                EventHandler.on(this._element, eventIn, this._config.selector, (event)=>{\n                    const context = this._initializeOnDelegatedTarget(event);\n                    context._activeTrigger[event.type === \"focusin\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n                    context._enter();\n                });\n                EventHandler.on(this._element, eventOut, this._config.selector, (event)=>{\n                    const context = this._initializeOnDelegatedTarget(event);\n                    context._activeTrigger[event.type === \"focusout\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n                    context._leave();\n                });\n            }\n        }\n        this._hideModalHandler = ()=>{\n            if (this._element) {\n                this.hide();\n            }\n        };\n        EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n    }\n    _fixTitle() {\n        const title = this._element.getAttribute(\"title\");\n        if (!title) {\n            return;\n        }\n        if (!this._element.getAttribute(\"aria-label\") && !this._element.textContent.trim()) {\n            this._element.setAttribute(\"aria-label\", title);\n        }\n        this._element.setAttribute(\"data-bs-original-title\", title); // DO NOT USE IT. Is only for backwards compatibility\n        this._element.removeAttribute(\"title\");\n    }\n    _enter() {\n        if (this._isShown() || this._isHovered) {\n            this._isHovered = true;\n            return;\n        }\n        this._isHovered = true;\n        this._setTimeout(()=>{\n            if (this._isHovered) {\n                this.show();\n            }\n        }, this._config.delay.show);\n    }\n    _leave() {\n        if (this._isWithActiveTrigger()) {\n            return;\n        }\n        this._isHovered = false;\n        this._setTimeout(()=>{\n            if (!this._isHovered) {\n                this.hide();\n            }\n        }, this._config.delay.hide);\n    }\n    _setTimeout(handler, timeout) {\n        clearTimeout(this._timeout);\n        this._timeout = setTimeout(handler, timeout);\n    }\n    _isWithActiveTrigger() {\n        return Object.values(this._activeTrigger).includes(true);\n    }\n    _getConfig(config) {\n        const dataAttributes = Manipulator.getDataAttributes(this._element);\n        for (const dataAttribute of Object.keys(dataAttributes)){\n            if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n                delete dataAttributes[dataAttribute];\n            }\n        }\n        config = {\n            ...dataAttributes,\n            ...typeof config === \"object\" && config ? config : {}\n        };\n        config = this._mergeConfigObj(config);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n    }\n    _configAfterMerge(config) {\n        config.container = config.container === false ? document.body : getElement(config.container);\n        if (typeof config.delay === \"number\") {\n            config.delay = {\n                show: config.delay,\n                hide: config.delay\n            };\n        }\n        if (typeof config.title === \"number\") {\n            config.title = config.title.toString();\n        }\n        if (typeof config.content === \"number\") {\n            config.content = config.content.toString();\n        }\n        return config;\n    }\n    _getDelegateConfig() {\n        const config = {};\n        for (const [key, value] of Object.entries(this._config)){\n            if (this.constructor.Default[key] !== value) {\n                config[key] = value;\n            }\n        }\n        config.selector = false;\n        config.trigger = \"manual\";\n        // In the future can be replaced with:\n        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n        // `Object.fromEntries(keysWithDifferentValues)`\n        return config;\n    }\n    _disposePopper() {\n        if (this._popper) {\n            this._popper.destroy();\n            this._popper = null;\n        }\n        if (this.tip) {\n            this.tip.remove();\n            this.tip = null;\n        }\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Tooltip.getOrCreateInstance(this, config);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (typeof data[config] === \"undefined\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config]();\n        });\n    }\n}\n/**\n * jQuery\n */ defineJQueryPlugin(Tooltip);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$3 = \"popover\";\nconst SELECTOR_TITLE = \".popover-header\";\nconst SELECTOR_CONTENT = \".popover-body\";\nconst Default$2 = {\n    ...Tooltip.Default,\n    content: \"\",\n    offset: [\n        0,\n        8\n    ],\n    placement: \"right\",\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + \"</div>\",\n    trigger: \"click\"\n};\nconst DefaultType$2 = {\n    ...Tooltip.DefaultType,\n    content: \"(null|string|element|function)\"\n};\n/**\n * Class definition\n */ class Popover extends Tooltip {\n    // Getters\n    static get Default() {\n        return Default$2;\n    }\n    static get DefaultType() {\n        return DefaultType$2;\n    }\n    static get NAME() {\n        return NAME$3;\n    }\n    // Overrides\n    _isWithContent() {\n        return this._getTitle() || this._getContent();\n    }\n    // Private\n    _getContentForTemplate() {\n        return {\n            [SELECTOR_TITLE]: this._getTitle(),\n            [SELECTOR_CONTENT]: this._getContent()\n        };\n    }\n    _getContent() {\n        return this._resolvePossibleFunction(this._config.content);\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Popover.getOrCreateInstance(this, config);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (typeof data[config] === \"undefined\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config]();\n        });\n    }\n}\n/**\n * jQuery\n */ defineJQueryPlugin(Popover);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$2 = \"scrollspy\";\nconst DATA_KEY$2 = \"bs.scrollspy\";\nconst EVENT_KEY$2 = `.${DATA_KEY$2}`;\nconst DATA_API_KEY = \".data-api\";\nconst EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\nconst EVENT_CLICK = `click${EVENT_KEY$2}`;\nconst EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\nconst CLASS_NAME_DROPDOWN_ITEM = \"dropdown-item\";\nconst CLASS_NAME_ACTIVE$1 = \"active\";\nconst SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\nconst SELECTOR_TARGET_LINKS = \"[href]\";\nconst SELECTOR_NAV_LIST_GROUP = \".nav, .list-group\";\nconst SELECTOR_NAV_LINKS = \".nav-link\";\nconst SELECTOR_NAV_ITEMS = \".nav-item\";\nconst SELECTOR_LIST_ITEMS = \".list-group-item\";\nconst SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\nconst SELECTOR_DROPDOWN = \".dropdown\";\nconst SELECTOR_DROPDOWN_TOGGLE$1 = \".dropdown-toggle\";\nconst Default$1 = {\n    offset: null,\n    // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: \"0px 0px -25%\",\n    smoothScroll: false,\n    target: null,\n    threshold: [\n        0.1,\n        0.5,\n        1\n    ]\n};\nconst DefaultType$1 = {\n    offset: \"(number|null)\",\n    // TODO v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: \"string\",\n    smoothScroll: \"boolean\",\n    target: \"element\",\n    threshold: \"array\"\n};\n/**\n * Class definition\n */ class ScrollSpy extends BaseComponent {\n    constructor(element, config){\n        super(element, config);\n        // this._element is the observablesContainer and config.target the menu links wrapper\n        this._targetLinks = new Map();\n        this._observableSections = new Map();\n        this._rootElement = getComputedStyle(this._element).overflowY === \"visible\" ? null : this._element;\n        this._activeTarget = null;\n        this._observer = null;\n        this._previousScrollData = {\n            visibleEntryTop: 0,\n            parentScrollTop: 0\n        };\n        this.refresh(); // initialize\n    }\n    // Getters\n    static get Default() {\n        return Default$1;\n    }\n    static get DefaultType() {\n        return DefaultType$1;\n    }\n    static get NAME() {\n        return NAME$2;\n    }\n    // Public\n    refresh() {\n        this._initializeTargetsAndObservables();\n        this._maybeEnableSmoothScroll();\n        if (this._observer) {\n            this._observer.disconnect();\n        } else {\n            this._observer = this._getNewObserver();\n        }\n        for (const section of this._observableSections.values()){\n            this._observer.observe(section);\n        }\n    }\n    dispose() {\n        this._observer.disconnect();\n        super.dispose();\n    }\n    // Private\n    _configAfterMerge(config) {\n        // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n        config.target = getElement(config.target) || document.body;\n        // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n        config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\n        if (typeof config.threshold === \"string\") {\n            config.threshold = config.threshold.split(\",\").map((value)=>Number.parseFloat(value));\n        }\n        return config;\n    }\n    _maybeEnableSmoothScroll() {\n        if (!this._config.smoothScroll) {\n            return;\n        }\n        // unregister any previous listeners\n        EventHandler.off(this._config.target, EVENT_CLICK);\n        EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event)=>{\n            const observableSection = this._observableSections.get(event.target.hash);\n            if (observableSection) {\n                event.preventDefault();\n                const root = this._rootElement || window;\n                const height = observableSection.offsetTop - this._element.offsetTop;\n                if (root.scrollTo) {\n                    root.scrollTo({\n                        top: height,\n                        behavior: \"smooth\"\n                    });\n                    return;\n                }\n                // Chrome 60 doesn't support `scrollTo`\n                root.scrollTop = height;\n            }\n        });\n    }\n    _getNewObserver() {\n        const options = {\n            root: this._rootElement,\n            threshold: this._config.threshold,\n            rootMargin: this._config.rootMargin\n        };\n        return new IntersectionObserver((entries)=>this._observerCallback(entries), options);\n    }\n    // The logic of selection\n    _observerCallback(entries) {\n        const targetElement = (entry)=>this._targetLinks.get(`#${entry.target.id}`);\n        const activate = (entry)=>{\n            this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n            this._process(targetElement(entry));\n        };\n        const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n        const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n        this._previousScrollData.parentScrollTop = parentScrollTop;\n        for (const entry of entries){\n            if (!entry.isIntersecting) {\n                this._activeTarget = null;\n                this._clearActiveClass(targetElement(entry));\n                continue;\n            }\n            const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\n            // if we are scrolling down, pick the bigger offsetTop\n            if (userScrollsDown && entryIsLowerThanPrevious) {\n                activate(entry);\n                // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n                if (!parentScrollTop) {\n                    return;\n                }\n                continue;\n            }\n            // if we are scrolling up, pick the smallest offsetTop\n            if (!userScrollsDown && !entryIsLowerThanPrevious) {\n                activate(entry);\n            }\n        }\n    }\n    _initializeTargetsAndObservables() {\n        this._targetLinks = new Map();\n        this._observableSections = new Map();\n        const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n        for (const anchor of targetLinks){\n            // ensure that the anchor has an id and is not disabled\n            if (!anchor.hash || isDisabled(anchor)) {\n                continue;\n            }\n            const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\n            // ensure that the observableSection exists & is visible\n            if (isVisible(observableSection)) {\n                this._targetLinks.set(decodeURI(anchor.hash), anchor);\n                this._observableSections.set(anchor.hash, observableSection);\n            }\n        }\n    }\n    _process(target) {\n        if (this._activeTarget === target) {\n            return;\n        }\n        this._clearActiveClass(this._config.target);\n        this._activeTarget = target;\n        target.classList.add(CLASS_NAME_ACTIVE$1);\n        this._activateParents(target);\n        EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n            relatedTarget: target\n        });\n    }\n    _activateParents(target) {\n        // Activate dropdown parents\n        if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n            SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n            return;\n        }\n        for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)){\n            // Set triggered links parents as active\n            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n            for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)){\n                item.classList.add(CLASS_NAME_ACTIVE$1);\n            }\n        }\n    }\n    _clearActiveClass(parent) {\n        parent.classList.remove(CLASS_NAME_ACTIVE$1);\n        const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\n        for (const node of activeNodes){\n            node.classList.remove(CLASS_NAME_ACTIVE$1);\n        }\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = ScrollSpy.getOrCreateInstance(this, config);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config]();\n        });\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{\n    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)){\n        ScrollSpy.getOrCreateInstance(spy);\n    }\n});\n/**\n * jQuery\n */ defineJQueryPlugin(ScrollSpy);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME$1 = \"tab\";\nconst DATA_KEY$1 = \"bs.tab\";\nconst EVENT_KEY$1 = `.${DATA_KEY$1}`;\nconst EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\nconst EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\nconst EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\nconst EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\nconst ARROW_LEFT_KEY = \"ArrowLeft\";\nconst ARROW_RIGHT_KEY = \"ArrowRight\";\nconst ARROW_UP_KEY = \"ArrowUp\";\nconst ARROW_DOWN_KEY = \"ArrowDown\";\nconst HOME_KEY = \"Home\";\nconst END_KEY = \"End\";\nconst CLASS_NAME_ACTIVE = \"active\";\nconst CLASS_NAME_FADE$1 = \"fade\";\nconst CLASS_NAME_SHOW$1 = \"show\";\nconst CLASS_DROPDOWN = \"dropdown\";\nconst SELECTOR_DROPDOWN_TOGGLE = \".dropdown-toggle\";\nconst SELECTOR_DROPDOWN_MENU = \".dropdown-menu\";\nconst NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\nconst SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\nconst SELECTOR_OUTER = \".nav-item, .list-group-item\";\nconst SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\nconst SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\nconst SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\nconst SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\n/**\n * Class definition\n */ class Tab extends BaseComponent {\n    constructor(element){\n        super(element);\n        this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n        if (!this._parent) {\n            return;\n        // TODO: should throw exception in v6\n        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n        }\n        // Set up initial aria attributes\n        this._setInitialAttributes(this._parent, this._getChildren());\n        EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event));\n    }\n    // Getters\n    static get NAME() {\n        return NAME$1;\n    }\n    // Public\n    show() {\n        // Shows this elem and deactivate the active sibling if exists\n        const innerElem = this._element;\n        if (this._elemIsActive(innerElem)) {\n            return;\n        }\n        // Search for active tab on same parent to deactivate it\n        const active = this._getActiveElem();\n        const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n            relatedTarget: innerElem\n        }) : null;\n        const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n            relatedTarget: active\n        });\n        if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n            return;\n        }\n        this._deactivate(active, innerElem);\n        this._activate(innerElem, active);\n    }\n    // Private\n    _activate(element, relatedElem) {\n        if (!element) {\n            return;\n        }\n        element.classList.add(CLASS_NAME_ACTIVE);\n        this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\n        const complete = ()=>{\n            if (element.getAttribute(\"role\") !== \"tab\") {\n                element.classList.add(CLASS_NAME_SHOW$1);\n                return;\n            }\n            element.removeAttribute(\"tabindex\");\n            element.setAttribute(\"aria-selected\", true);\n            this._toggleDropDown(element, true);\n            EventHandler.trigger(element, EVENT_SHOWN$1, {\n                relatedTarget: relatedElem\n            });\n        };\n        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n    }\n    _deactivate(element, relatedElem) {\n        if (!element) {\n            return;\n        }\n        element.classList.remove(CLASS_NAME_ACTIVE);\n        element.blur();\n        this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\n        const complete = ()=>{\n            if (element.getAttribute(\"role\") !== \"tab\") {\n                element.classList.remove(CLASS_NAME_SHOW$1);\n                return;\n            }\n            element.setAttribute(\"aria-selected\", false);\n            element.setAttribute(\"tabindex\", \"-1\");\n            this._toggleDropDown(element, false);\n            EventHandler.trigger(element, EVENT_HIDDEN$1, {\n                relatedTarget: relatedElem\n            });\n        };\n        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n    }\n    _keydown(event) {\n        if (![\n            ARROW_LEFT_KEY,\n            ARROW_RIGHT_KEY,\n            ARROW_UP_KEY,\n            ARROW_DOWN_KEY,\n            HOME_KEY,\n            END_KEY\n        ].includes(event.key)) {\n            return;\n        }\n        event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n        event.preventDefault();\n        const children = this._getChildren().filter((element)=>!isDisabled(element));\n        let nextActiveElement;\n        if ([\n            HOME_KEY,\n            END_KEY\n        ].includes(event.key)) {\n            nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\n        } else {\n            const isNext = [\n                ARROW_RIGHT_KEY,\n                ARROW_DOWN_KEY\n            ].includes(event.key);\n            nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\n        }\n        if (nextActiveElement) {\n            nextActiveElement.focus({\n                preventScroll: true\n            });\n            Tab.getOrCreateInstance(nextActiveElement).show();\n        }\n    }\n    _getChildren() {\n        // collection of inner elements\n        return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n    }\n    _getActiveElem() {\n        return this._getChildren().find((child)=>this._elemIsActive(child)) || null;\n    }\n    _setInitialAttributes(parent, children) {\n        this._setAttributeIfNotExists(parent, \"role\", \"tablist\");\n        for (const child of children){\n            this._setInitialAttributesOnChild(child);\n        }\n    }\n    _setInitialAttributesOnChild(child) {\n        child = this._getInnerElement(child);\n        const isActive = this._elemIsActive(child);\n        const outerElem = this._getOuterElement(child);\n        child.setAttribute(\"aria-selected\", isActive);\n        if (outerElem !== child) {\n            this._setAttributeIfNotExists(outerElem, \"role\", \"presentation\");\n        }\n        if (!isActive) {\n            child.setAttribute(\"tabindex\", \"-1\");\n        }\n        this._setAttributeIfNotExists(child, \"role\", \"tab\");\n        // set attributes to the related panel too\n        this._setInitialAttributesOnTargetPanel(child);\n    }\n    _setInitialAttributesOnTargetPanel(child) {\n        const target = SelectorEngine.getElementFromSelector(child);\n        if (!target) {\n            return;\n        }\n        this._setAttributeIfNotExists(target, \"role\", \"tabpanel\");\n        if (child.id) {\n            this._setAttributeIfNotExists(target, \"aria-labelledby\", `${child.id}`);\n        }\n    }\n    _toggleDropDown(element, open) {\n        const outerElem = this._getOuterElement(element);\n        if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n            return;\n        }\n        const toggle = (selector, className)=>{\n            const element = SelectorEngine.findOne(selector, outerElem);\n            if (element) {\n                element.classList.toggle(className, open);\n            }\n        };\n        toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n        toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n        outerElem.setAttribute(\"aria-expanded\", open);\n    }\n    _setAttributeIfNotExists(element, attribute, value) {\n        if (!element.hasAttribute(attribute)) {\n            element.setAttribute(attribute, value);\n        }\n    }\n    _elemIsActive(elem) {\n        return elem.classList.contains(CLASS_NAME_ACTIVE);\n    }\n    // Try to get the inner element (usually the .nav-link)\n    _getInnerElement(elem) {\n        return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n    }\n    // Try to get the outer element (usually the .nav-item)\n    _getOuterElement(elem) {\n        return elem.closest(SELECTOR_OUTER) || elem;\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Tab.getOrCreateInstance(this);\n            if (typeof config !== \"string\") {\n                return;\n            }\n            if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                throw new TypeError(`No method named \"${config}\"`);\n            }\n            data[config]();\n        });\n    }\n}\n/**\n * Data API implementation\n */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {\n    if ([\n        \"A\",\n        \"AREA\"\n    ].includes(this.tagName)) {\n        event.preventDefault();\n    }\n    if (isDisabled(this)) {\n        return;\n    }\n    Tab.getOrCreateInstance(this).show();\n});\n/**\n * Initialize on focus\n */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{\n    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)){\n        Tab.getOrCreateInstance(element);\n    }\n});\n/**\n * jQuery\n */ defineJQueryPlugin(Tab);\n/**\n * --------------------------------------------------------------------------\n * Bootstrap toast.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */ /**\n * Constants\n */ const NAME = \"toast\";\nconst DATA_KEY = \"bs.toast\";\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\nconst EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\nconst EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\nconst EVENT_SHOW = `show${EVENT_KEY}`;\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\nconst CLASS_NAME_FADE = \"fade\";\nconst CLASS_NAME_HIDE = \"hide\"; // @deprecated - kept here only for backwards compatibility\nconst CLASS_NAME_SHOW = \"show\";\nconst CLASS_NAME_SHOWING = \"showing\";\nconst DefaultType = {\n    animation: \"boolean\",\n    autohide: \"boolean\",\n    delay: \"number\"\n};\nconst Default = {\n    animation: true,\n    autohide: true,\n    delay: 5000\n};\n/**\n * Class definition\n */ class Toast extends BaseComponent {\n    constructor(element, config){\n        super(element, config);\n        this._timeout = null;\n        this._hasMouseInteraction = false;\n        this._hasKeyboardInteraction = false;\n        this._setListeners();\n    }\n    // Getters\n    static get Default() {\n        return Default;\n    }\n    static get DefaultType() {\n        return DefaultType;\n    }\n    static get NAME() {\n        return NAME;\n    }\n    // Public\n    show() {\n        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n        if (showEvent.defaultPrevented) {\n            return;\n        }\n        this._clearTimeout();\n        if (this._config.animation) {\n            this._element.classList.add(CLASS_NAME_FADE);\n        }\n        const complete = ()=>{\n            this._element.classList.remove(CLASS_NAME_SHOWING);\n            EventHandler.trigger(this._element, EVENT_SHOWN);\n            this._maybeScheduleHide();\n        };\n        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n        this._queueCallback(complete, this._element, this._config.animation);\n    }\n    hide() {\n        if (!this.isShown()) {\n            return;\n        }\n        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n        if (hideEvent.defaultPrevented) {\n            return;\n        }\n        const complete = ()=>{\n            this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n            this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n            EventHandler.trigger(this._element, EVENT_HIDDEN);\n        };\n        this._element.classList.add(CLASS_NAME_SHOWING);\n        this._queueCallback(complete, this._element, this._config.animation);\n    }\n    dispose() {\n        this._clearTimeout();\n        if (this.isShown()) {\n            this._element.classList.remove(CLASS_NAME_SHOW);\n        }\n        super.dispose();\n    }\n    isShown() {\n        return this._element.classList.contains(CLASS_NAME_SHOW);\n    }\n    // Private\n    _maybeScheduleHide() {\n        if (!this._config.autohide) {\n            return;\n        }\n        if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n            return;\n        }\n        this._timeout = setTimeout(()=>{\n            this.hide();\n        }, this._config.delay);\n    }\n    _onInteraction(event, isInteracting) {\n        switch(event.type){\n            case \"mouseover\":\n            case \"mouseout\":\n                {\n                    this._hasMouseInteraction = isInteracting;\n                    break;\n                }\n            case \"focusin\":\n            case \"focusout\":\n                {\n                    this._hasKeyboardInteraction = isInteracting;\n                    break;\n                }\n        }\n        if (isInteracting) {\n            this._clearTimeout();\n            return;\n        }\n        const nextElement = event.relatedTarget;\n        if (this._element === nextElement || this._element.contains(nextElement)) {\n            return;\n        }\n        this._maybeScheduleHide();\n    }\n    _setListeners() {\n        EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true));\n        EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false));\n        EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true));\n        EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false));\n    }\n    _clearTimeout() {\n        clearTimeout(this._timeout);\n        this._timeout = null;\n    }\n    // Static\n    static jQueryInterface(config) {\n        return this.each(function() {\n            const data = Toast.getOrCreateInstance(this, config);\n            if (typeof config === \"string\") {\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config](this);\n            }\n        });\n    }\n}\n/**\n * Data API implementation\n */ enableDismissTrigger(Toast);\n/**\n * jQuery\n */ defineJQueryPlugin(Toast);\n //# sourceMappingURL=bootstrap.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0VBSUUsR0FDdUM7QUFFekM7Ozs7O0NBS0MsR0FFRDs7Q0FFQyxHQUVELE1BQU1DLGFBQWEsSUFBSUM7QUFDdkIsTUFBTUMsT0FBTztJQUNYQyxLQUFJQyxPQUFPLEVBQUVDLEdBQUcsRUFBRUMsUUFBUTtRQUN4QixJQUFJLENBQUNOLFdBQVdPLEdBQUcsQ0FBQ0gsVUFBVTtZQUM1QkosV0FBV0csR0FBRyxDQUFDQyxTQUFTLElBQUlIO1FBQzlCO1FBQ0EsTUFBTU8sY0FBY1IsV0FBV1MsR0FBRyxDQUFDTDtRQUVuQyxzREFBc0Q7UUFDdEQsdUVBQXVFO1FBQ3ZFLElBQUksQ0FBQ0ksWUFBWUQsR0FBRyxDQUFDRixRQUFRRyxZQUFZRSxJQUFJLEtBQUssR0FBRztZQUNuRCxzQ0FBc0M7WUFDdENDLFFBQVFDLEtBQUssQ0FBQyxDQUFDLDRFQUE0RSxFQUFFQyxNQUFNQyxJQUFJLENBQUNOLFlBQVlPLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDakk7UUFDRjtRQUNBUCxZQUFZTCxHQUFHLENBQUNFLEtBQUtDO0lBQ3ZCO0lBQ0FHLEtBQUlMLE9BQU8sRUFBRUMsR0FBRztRQUNkLElBQUlMLFdBQVdPLEdBQUcsQ0FBQ0gsVUFBVTtZQUMzQixPQUFPSixXQUFXUyxHQUFHLENBQUNMLFNBQVNLLEdBQUcsQ0FBQ0osUUFBUTtRQUM3QztRQUNBLE9BQU87SUFDVDtJQUNBVyxRQUFPWixPQUFPLEVBQUVDLEdBQUc7UUFDakIsSUFBSSxDQUFDTCxXQUFXTyxHQUFHLENBQUNILFVBQVU7WUFDNUI7UUFDRjtRQUNBLE1BQU1JLGNBQWNSLFdBQVdTLEdBQUcsQ0FBQ0w7UUFDbkNJLFlBQVlTLE1BQU0sQ0FBQ1o7UUFFbkIsMkVBQTJFO1FBQzNFLElBQUlHLFlBQVlFLElBQUksS0FBSyxH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QUNtMkIsY0FBYyxDQUFDbjJCLE9BQU87UUFDcEZJLGFBQWFpQyxFQUFFLENBQUMsSUFBSSxDQUFDaUUsUUFBUSxFQUFFMnVCLGdCQUFnQmoxQixDQUFBQSxRQUFTLElBQUksQ0FBQ20yQixjQUFjLENBQUNuMkIsT0FBTztRQUNuRkksYUFBYWlDLEVBQUUsQ0FBQyxJQUFJLENBQUNpRSxRQUFRLEVBQUU0dUIsZUFBZWwxQixDQUFBQSxRQUFTLElBQUksQ0FBQ20yQixjQUFjLENBQUNuMkIsT0FBTztRQUNsRkksYUFBYWlDLEVBQUUsQ0FBQyxJQUFJLENBQUNpRSxRQUFRLEVBQUU2dUIsZ0JBQWdCbjFCLENBQUFBLFFBQVMsSUFBSSxDQUFDbTJCLGNBQWMsQ0FBQ24yQixPQUFPO0lBQ3JGO0lBQ0FnMkIsZ0JBQWdCO1FBQ2Q5a0IsYUFBYSxJQUFJLENBQUMrWixRQUFRO1FBQzFCLElBQUksQ0FBQ0EsUUFBUSxHQUFHO0lBQ2xCO0lBRUEsU0FBUztJQUNULE9BQU8xdEIsZ0JBQWdCK0gsTUFBTSxFQUFFO1FBQzdCLE9BQU8sSUFBSSxDQUFDc0UsSUFBSSxDQUFDO1lBQ2YsTUFBTUMsT0FBT2dzQixNQUFNN3VCLG1CQUFtQixDQUFDLElBQUksRUFBRTFCO1lBQzdDLElBQUksT0FBT0EsV0FBVyxVQUFVO2dCQUM5QixJQUFJLE9BQU91RSxJQUFJLENBQUN2RSxPQUFPLEtBQUssYUFBYTtvQkFDdkMsTUFBTSxJQUFJWSxVQUFVLENBQUMsaUJBQWlCLEVBQUVaLE9BQU8sQ0FBQyxDQUFDO2dCQUNuRDtnQkFDQXVFLElBQUksQ0FBQ3ZFLE9BQU8sQ0FBQyxJQUFJO1lBQ25CO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FFRHNELHFCQUFxQml0QjtBQUVyQjs7Q0FFQyxHQUVENzRCLG1CQUFtQjY0QjtBQUUrRixDQUNsSCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXNpbXBsZS11aS8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuZXNtLmpzPzBhNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICogQm9vdHN0cmFwIHY1LjMuNiAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcbiAgKiBDb3B5cmlnaHQgMjAxMS0yMDI1IFRoZSBCb290c3RyYXAgQXV0aG9ycyAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2dyYXBocy9jb250cmlidXRvcnMpXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICovXG5pbXBvcnQgKiBhcyBQb3BwZXIgZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgZG9tL2RhdGEuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IGVsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XG5jb25zdCBEYXRhID0ge1xuICBzZXQoZWxlbWVudCwga2V5LCBpbnN0YW5jZSkge1xuICAgIGlmICghZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XG5cbiAgICAvLyBtYWtlIGl0IGNsZWFyIHdlIG9ubHkgd2FudCBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnRcbiAgICAvLyBjYW4gYmUgcmVtb3ZlZCBsYXRlciB3aGVuIG11bHRpcGxlIGtleS9pbnN0YW5jZXMgYXJlIGZpbmUgdG8gYmUgdXNlZFxuICAgIGlmICghaW5zdGFuY2VNYXAuaGFzKGtleSkgJiYgaW5zdGFuY2VNYXAuc2l6ZSAhPT0gMCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcbiAgfSxcbiAgZ2V0KGVsZW1lbnQsIGtleSkge1xuICAgIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpLmdldChrZXkpIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZW1vdmUoZWxlbWVudCwga2V5KSB7XG4gICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpO1xuICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpO1xuXG4gICAgLy8gZnJlZSB1cCBlbGVtZW50IHJlZmVyZW5jZXMgaWYgdGhlcmUgYXJlIG5vIGluc3RhbmNlcyBsZWZ0IGZvciBhbiBlbGVtZW50XG4gICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcbiAgICAgIGVsZW1lbnRNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvaW5kZXguanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBNQVhfVUlEID0gMTAwMDAwMDtcbmNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcbmNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnO1xuXG4vKipcbiAqIFByb3Blcmx5IGVzY2FwZSBJRHMgc2VsZWN0b3JzIHRvIGhhbmRsZSB3ZWlyZCBJRHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgcGFyc2VTZWxlY3RvciA9IHNlbGVjdG9yID0+IHtcbiAgaWYgKHNlbGVjdG9yICYmIHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5lc2NhcGUpIHtcbiAgICAvLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yIG5lZWRzIGVzY2FwaW5nIHRvIGhhbmRsZSBJRHMgKGh0bWw1KykgY29udGFpbmluZyBmb3IgaW5zdGFuY2UgL1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvIyhbXlxcc1wiIyddKykvZywgKG1hdGNoLCBpZCkgPT4gYCMke0NTUy5lc2NhcGUoaWQpfWApO1xuICB9XG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG5cbi8vIFNob3V0LW91dCBBbmd1cyBDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxuY29uc3QgdG9UeXBlID0gb2JqZWN0ID0+IHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgJHtvYmplY3R9YDtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFB1YmxpYyBVdGlsIEFQSVxuICovXG5cbmNvbnN0IGdldFVJRCA9IHByZWZpeCA9PiB7XG4gIGRvIHtcbiAgICBwcmVmaXggKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYX1VJRCk7XG4gIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpO1xuICByZXR1cm4gcHJlZml4O1xufTtcbmNvbnN0IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgdHJhbnNpdGlvbkRlbGF5XG4gIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7XG5cbiAgLy8gUmV0dXJuIDAgaWYgZWxlbWVudCBvciB0cmFuc2l0aW9uIGR1cmF0aW9uIGlzIG5vdCBmb3VuZFxuICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcbiAgdHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5LnNwbGl0KCcsJylbMF07XG4gIHJldHVybiAoTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKSArIE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSkpICogTUlMTElTRUNPTkRTX01VTFRJUExJRVI7XG59O1xuY29uc3QgdHJpZ2dlclRyYW5zaXRpb25FbmQgPSBlbGVtZW50ID0+IHtcbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChUUkFOU0lUSU9OX0VORCkpO1xufTtcbmNvbnN0IGlzRWxlbWVudCA9IG9iamVjdCA9PiB7XG4gIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2Ygb2JqZWN0LmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbMF07XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgIT09ICd1bmRlZmluZWQnO1xufTtcbmNvbnN0IGdldEVsZW1lbnQgPSBvYmplY3QgPT4ge1xuICAvLyBpdCdzIGEgalF1ZXJ5IG9iamVjdCBvciBhIG5vZGUgZWxlbWVudFxuICBpZiAoaXNFbGVtZW50KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0LmpxdWVyeSA/IG9iamVjdFswXSA6IG9iamVjdDtcbiAgfVxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihwYXJzZVNlbGVjdG9yKG9iamVjdCkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGlzVmlzaWJsZSA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWlzRWxlbWVudChlbGVtZW50KSB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRJc1Zpc2libGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnO1xuICAvLyBIYW5kbGUgYGRldGFpbHNgIGVsZW1lbnQgYXMgaXRzIGNvbnRlbnQgbWF5IGZhbHNpZSBhcHBlYXIgdmlzaWJsZSB3aGVuIGl0IGlzIGNsb3NlZFxuICBjb25zdCBjbG9zZWREZXRhaWxzID0gZWxlbWVudC5jbG9zZXN0KCdkZXRhaWxzOm5vdChbb3Blbl0pJyk7XG4gIGlmICghY2xvc2VkRGV0YWlscykge1xuICAgIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xuICB9XG4gIGlmIChjbG9zZWREZXRhaWxzICE9PSBlbGVtZW50KSB7XG4gICAgY29uc3Qgc3VtbWFyeSA9IGVsZW1lbnQuY2xvc2VzdCgnc3VtbWFyeScpO1xuICAgIGlmIChzdW1tYXJ5ICYmIHN1bW1hcnkucGFyZW50Tm9kZSAhPT0gY2xvc2VkRGV0YWlscykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3VtbWFyeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcbn07XG5jb25zdCBpc0Rpc2FibGVkID0gZWxlbWVudCA9PiB7XG4gIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgZWxlbWVudC5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgIT09ICdmYWxzZSc7XG59O1xuY29uc3QgZmluZFNoYWRvd1Jvb3QgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3Qgcm9vdCA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbDtcbiAgfVxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XG4gIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpbmRTaGFkb3dSb290KGVsZW1lbnQucGFyZW50Tm9kZSk7XG59O1xuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIFRyaWNrIHRvIHJlc3RhcnQgYW4gZWxlbWVudCdzIGFuaW1hdGlvblxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4gdm9pZFxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cuaGFycnl0aGVvLmNvbS9ibG9nLzIwMjEvMDIvcmVzdGFydC1hLWNzcy1hbmltYXRpb24td2l0aC1qYXZhc2NyaXB0LyNyZXN0YXJ0aW5nLWEtY3NzLWFuaW1hdGlvblxuICovXG5jb25zdCByZWZsb3cgPSBlbGVtZW50ID0+IHtcbiAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG59O1xuY29uc3QgZ2V0alF1ZXJ5ID0gKCkgPT4ge1xuICBpZiAod2luZG93LmpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcbiAgICByZXR1cm4gd2luZG93LmpRdWVyeTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzID0gW107XG5jb25zdCBvbkRPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAvLyBhZGQgbGlzdGVuZXIgb24gdGhlIGZpcnN0IGNhbGwgd2hlbiB0aGUgZG9jdW1lbnQgaXMgaW4gbG9hZGluZyBzdGF0ZVxuICAgIGlmICghRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5jb25zdCBpc1JUTCA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09ICdydGwnO1xuY29uc3QgZGVmaW5lSlF1ZXJ5UGx1Z2luID0gcGx1Z2luID0+IHtcbiAgb25ET01Db250ZW50TG9hZGVkKCgpID0+IHtcbiAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCQpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwbHVnaW4uTkFNRTtcbiAgICAgIGNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bbmFtZV07XG4gICAgICAkLmZuW25hbWVdID0gcGx1Z2luLmpRdWVyeUludGVyZmFjZTtcbiAgICAgICQuZm5bbmFtZV0uQ29uc3RydWN0b3IgPSBwbHVnaW47XG4gICAgICAkLmZuW25hbWVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICAgICAgICQuZm5bbmFtZV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICAgIHJldHVybiBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGV4ZWN1dGUgPSAocG9zc2libGVDYWxsYmFjaywgYXJncyA9IFtdLCBkZWZhdWx0VmFsdWUgPSBwb3NzaWJsZUNhbGxiYWNrKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgcG9zc2libGVDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IHBvc3NpYmxlQ2FsbGJhY2suY2FsbCguLi5hcmdzKSA6IGRlZmF1bHRWYWx1ZTtcbn07XG5jb25zdCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uID0gKGNhbGxiYWNrLCB0cmFuc2l0aW9uRWxlbWVudCwgd2FpdEZvclRyYW5zaXRpb24gPSB0cnVlKSA9PiB7XG4gIGlmICghd2FpdEZvclRyYW5zaXRpb24pIHtcbiAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNTtcbiAgY29uc3QgZW11bGF0ZWREdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRyYW5zaXRpb25FbGVtZW50KSArIGR1cmF0aW9uUGFkZGluZztcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICBjb25zdCBoYW5kbGVyID0gKHtcbiAgICB0YXJnZXRcbiAgfSkgPT4ge1xuICAgIGlmICh0YXJnZXQgIT09IHRyYW5zaXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgdHJhbnNpdGlvbkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XG4gICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gIH07XG4gIHRyYW5zaXRpb25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGhhbmRsZXIpO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgfSwgZW11bGF0ZWREdXJhdGlvbik7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgcHJldmlvdXMvbmV4dCBlbGVtZW50IG9mIGEgbGlzdC5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBsaXN0ICAgIFRoZSBsaXN0IG9mIGVsZW1lbnRzXG4gKiBAcGFyYW0gYWN0aXZlRWxlbWVudCAgIFRoZSBhY3RpdmUgZWxlbWVudFxuICogQHBhcmFtIHNob3VsZEdldE5leHQgICBDaG9vc2UgdG8gZ2V0IG5leHQgb3IgcHJldmlvdXMgZWxlbWVudFxuICogQHBhcmFtIGlzQ3ljbGVBbGxvd2VkXG4gKiBAcmV0dXJuIHtFbGVtZW50fGVsZW19IFRoZSBwcm9wZXIgZWxlbWVudFxuICovXG5jb25zdCBnZXROZXh0QWN0aXZlRWxlbWVudCA9IChsaXN0LCBhY3RpdmVFbGVtZW50LCBzaG91bGRHZXROZXh0LCBpc0N5Y2xlQWxsb3dlZCkgPT4ge1xuICBjb25zdCBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIGxldCBpbmRleCA9IGxpc3QuaW5kZXhPZihhY3RpdmVFbGVtZW50KTtcblxuICAvLyBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbGlzdCByZXR1cm4gYW4gZWxlbWVudFxuICAvLyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhbmQgaWYgY3ljbGUgaXMgYWxsb3dlZFxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuICFzaG91bGRHZXROZXh0ICYmIGlzQ3ljbGVBbGxvd2VkID8gbGlzdFtsaXN0TGVuZ3RoIC0gMV0gOiBsaXN0WzBdO1xuICB9XG4gIGluZGV4ICs9IHNob3VsZEdldE5leHQgPyAxIDogLTE7XG4gIGlmIChpc0N5Y2xlQWxsb3dlZCkge1xuICAgIGluZGV4ID0gKGluZGV4ICsgbGlzdExlbmd0aCkgJSBsaXN0TGVuZ3RoO1xuICB9XG4gIHJldHVybiBsaXN0W01hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBsaXN0TGVuZ3RoIC0gMSkpXTtcbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBkb20vZXZlbnQtaGFuZGxlci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi87XG5jb25zdCBzdHJpcE5hbWVSZWdleCA9IC9cXC4uKi87XG5jb25zdCBzdHJpcFVpZFJlZ2V4ID0gLzo6XFxkKyQvO1xuY29uc3QgZXZlbnRSZWdpc3RyeSA9IHt9OyAvLyBFdmVudHMgc3RvcmFnZVxubGV0IHVpZEV2ZW50ID0gMTtcbmNvbnN0IGN1c3RvbUV2ZW50cyA9IHtcbiAgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXG4gIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcbn07XG5jb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnY29udGV4dG1lbnUnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3NlbGVjdHN0YXJ0JywgJ3NlbGVjdGVuZCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ29yaWVudGF0aW9uY2hhbmdlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVybGVhdmUnLCAncG9pbnRlcmNhbmNlbCcsICdnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZWNoYW5nZScsICdnZXN0dXJlZW5kJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ3Jlc2V0JywgJ3NlbGVjdCcsICdzdWJtaXQnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdsb2FkJywgJ3VubG9hZCcsICdiZWZvcmV1bmxvYWQnLCAncmVzaXplJywgJ21vdmUnLCAnRE9NQ29udGVudExvYWRlZCcsICdyZWFkeXN0YXRlY2hhbmdlJywgJ2Vycm9yJywgJ2Fib3J0JywgJ3Njcm9sbCddKTtcblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZHNcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRXZlbnRVaWQoZWxlbWVudCwgdWlkKSB7XG4gIHJldHVybiB1aWQgJiYgYCR7dWlkfTo6JHt1aWRFdmVudCsrfWAgfHwgZWxlbWVudC51aWRFdmVudCB8fCB1aWRFdmVudCsrO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KSB7XG4gIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChlbGVtZW50KTtcbiAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcbiAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9O1xuICByZXR1cm4gZXZlbnRSZWdpc3RyeVt1aWRdO1xufVxuZnVuY3Rpb24gYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcbiAgICAgIGRlbGVnYXRlVGFyZ2V0OiBlbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pO1xuICB9O1xufVxuZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAobGV0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb21FbGVtZW50cykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaHlkcmF0ZU9iaihldmVudCwge1xuICAgICAgICAgIGRlbGVnYXRlVGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgc2VsZWN0b3IsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGFyZ2V0LCBbZXZlbnRdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kSGFuZGxlcihldmVudHMsIGNhbGxhYmxlLCBkZWxlZ2F0aW9uU2VsZWN0b3IgPSBudWxsKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGV2ZW50cykuZmluZChldmVudCA9PiBldmVudC5jYWxsYWJsZSA9PT0gY2FsbGFibGUgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gIGNvbnN0IGlzRGVsZWdhdGVkID0gdHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnO1xuICAvLyBUT0RPOiB0b29sdGlwIHBhc3NlcyBgZmFsc2VgIGluc3RlYWQgb2Ygc2VsZWN0b3IsIHNvIHdlIG5lZWQgdG8gY2hlY2tcbiAgY29uc3QgY2FsbGFibGUgPSBpc0RlbGVnYXRlZCA/IGRlbGVnYXRpb25GdW5jdGlvbiA6IGhhbmRsZXIgfHwgZGVsZWdhdGlvbkZ1bmN0aW9uO1xuICBsZXQgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KG9yaWdpbmFsVHlwZUV2ZW50KTtcbiAgaWYgKCFuYXRpdmVFdmVudHMuaGFzKHR5cGVFdmVudCkpIHtcbiAgICB0eXBlRXZlbnQgPSBvcmlnaW5hbFR5cGVFdmVudDtcbiAgfVxuICByZXR1cm4gW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XTtcbn1cbmZ1bmN0aW9uIGFkZEhhbmRsZXIoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgb25lT2ZmKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcblxuICAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXG4gIC8vIHRoaXMgcHJldmVudHMgdGhlIGhhbmRsZXIgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRoZSBzYW1lIHdheSBhcyBtb3VzZW92ZXIgb3IgbW91c2VvdXQgZG9lc1xuICBpZiAob3JpZ2luYWxUeXBlRXZlbnQgaW4gY3VzdG9tRXZlbnRzKSB7XG4gICAgY29uc3Qgd3JhcEZ1bmN0aW9uID0gZm4gPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQucmVsYXRlZFRhcmdldCAhPT0gZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgIWV2ZW50LmRlbGVnYXRlVGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgY2FsbGFibGUgPSB3cmFwRnVuY3Rpb24oY2FsbGFibGUpO1xuICB9XG4gIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XG4gIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xuICBjb25zdCBwcmV2aW91c0Z1bmN0aW9uID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKTtcbiAgaWYgKHByZXZpb3VzRnVuY3Rpb24pIHtcbiAgICBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiA9IHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmICYmIG9uZU9mZjtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGNhbGxhYmxlLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpO1xuICBjb25zdCBmbiA9IGlzRGVsZWdhdGVkID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgY2FsbGFibGUpIDogYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBjYWxsYWJsZSk7XG4gIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGw7XG4gIGZuLmNhbGxhYmxlID0gY2FsbGFibGU7XG4gIGZuLm9uZU9mZiA9IG9uZU9mZjtcbiAgZm4udWlkRXZlbnQgPSB1aWQ7XG4gIGhhbmRsZXJzW3VpZF0gPSBmbjtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIGlzRGVsZWdhdGVkKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcikge1xuICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpO1xuICBkZWxldGUgZXZlbnRzW3R5cGVFdmVudF1bZm4udWlkRXZlbnRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcbiAgZm9yIChjb25zdCBbaGFuZGxlcktleSwgZXZlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xuICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHlwZUV2ZW50KGV2ZW50KSB7XG4gIC8vIGFsbG93IHRvIGdldCB0aGUgbmF0aXZlIGV2ZW50cyBmcm9tIG5hbWVzcGFjZWQgZXZlbnRzICgnY2xpY2suYnMuYnV0dG9uJyAtLT4gJ2NsaWNrJylcbiAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XG4gIHJldHVybiBjdXN0b21FdmVudHNbZXZlbnRdIHx8IGV2ZW50O1xufVxuY29uc3QgRXZlbnRIYW5kbGVyID0ge1xuICBvbihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBmYWxzZSk7XG4gIH0sXG4gIG9uZShlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCB0cnVlKTtcbiAgfSxcbiAgb2ZmKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IHR5cGVFdmVudCAhPT0gb3JpZ2luYWxUeXBlRXZlbnQ7XG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcbiAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xuICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xuICAgIGlmICh0eXBlb2YgY2FsbGFibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc05hbWVzcGFjZSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50RXZlbnQgb2YgT2JqZWN0LmtleXMoZXZlbnRzKSkge1xuICAgICAgICByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCBlbGVtZW50RXZlbnQsIG9yaWdpbmFsVHlwZUV2ZW50LnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5SGFuZGxlcnMsIGV2ZW50XSBvZiBPYmplY3QuZW50cmllcyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBrZXlIYW5kbGVycy5yZXBsYWNlKHN0cmlwVWlkUmVnZXgsICcnKTtcbiAgICAgIGlmICghaW5OYW1lc3BhY2UgfHwgb3JpZ2luYWxUeXBlRXZlbnQuaW5jbHVkZXMoaGFuZGxlcktleSkpIHtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XG4gICAgY29uc3QgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnQ7XG4gICAgbGV0IGpRdWVyeUV2ZW50ID0gbnVsbDtcbiAgICBsZXQgYnViYmxlcyA9IHRydWU7XG4gICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZTtcbiAgICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgIGlmIChpbk5hbWVzcGFjZSAmJiAkKSB7XG4gICAgICBqUXVlcnlFdmVudCA9ICQuRXZlbnQoZXZlbnQsIGFyZ3MpO1xuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KTtcbiAgICAgIGJ1YmJsZXMgPSAhalF1ZXJ5RXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgIG5hdGl2ZURpc3BhdGNoID0gIWpRdWVyeUV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCk7XG4gICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IGV2dCA9IGh5ZHJhdGVPYmoobmV3IEV2ZW50KGV2ZW50LCB7XG4gICAgICBidWJibGVzLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pLCBhcmdzKTtcbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xuICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiBqUXVlcnlFdmVudCkge1xuICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2dDtcbiAgfVxufTtcbmZ1bmN0aW9uIGh5ZHJhdGVPYmoob2JqLCBtZXRhID0ge30pIHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YSkpIHtcbiAgICB0cnkge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGRvbS9tYW5pcHVsYXRvci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBOdW1iZXIodmFsdWUpLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGNociA9PiBgLSR7Y2hyLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5jb25zdCBNYW5pcHVsYXRvciA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCwgdmFsdWUpO1xuICB9LFxuICByZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApO1xuICB9LFxuICBnZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBjb25zdCBic0tleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykgJiYgIWtleS5zdGFydHNXaXRoKCdic0NvbmZpZycpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBic0tleXMpIHtcbiAgICAgIGxldCBwdXJlS2V5ID0ga2V5LnJlcGxhY2UoL15icy8sICcnKTtcbiAgICAgIHB1cmVLZXkgPSBwdXJlS2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcHVyZUtleS5zbGljZSgxKTtcbiAgICAgIGF0dHJpYnV0ZXNbcHVyZUtleV0gPSBub3JtYWxpemVEYXRhKGVsZW1lbnQuZGF0YXNldFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZURhdGEoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCkpO1xuICB9XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC9jb25maWcuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIENvbmZpZyB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHN0YXRpYyBtZXRob2QgXCJOQU1FXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnKTtcbiAgfVxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XG4gICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfbWVyZ2VDb25maWdPYmooY29uZmlnLCBlbGVtZW50KSB7XG4gICAgY29uc3QganNvbkNvbmZpZyA9IGlzRWxlbWVudChlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgJ2NvbmZpZycpIDoge307IC8vIHRyeSB0byBwYXJzZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLih0eXBlb2YganNvbkNvbmZpZyA9PT0gJ29iamVjdCcgPyBqc29uQ29uZmlnIDoge30pLFxuICAgICAgLi4uKGlzRWxlbWVudChlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIDoge30pLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgfVxuICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZywgY29uZmlnVHlwZXMgPSB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSB7XG4gICAgZm9yIChjb25zdCBbcHJvcGVydHksIGV4cGVjdGVkVHlwZXNdIG9mIE9iamVjdC5lbnRyaWVzKGNvbmZpZ1R5cGVzKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gaXNFbGVtZW50KHZhbHVlKSA/ICdlbGVtZW50JyA6IHRvVHlwZSh2YWx1ZSk7XG4gICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke3Byb3BlcnR5fVwiIHByb3ZpZGVkIHR5cGUgXCIke3ZhbHVlVHlwZX1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7ZXhwZWN0ZWRUeXBlc31cIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGJhc2UtY29tcG9uZW50LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IFZFUlNJT04gPSAnNS4zLjYnO1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICBlbGVtZW50ID0gZ2V0RWxlbWVudChlbGVtZW50KTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBEYXRhLnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xuICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQpO1xuICB9XG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnLCB0aGlzLl9lbGVtZW50KTtcbiAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG4gICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xuICAgIHJldHVybiBEYXRhLmdldChnZXRFbGVtZW50KGVsZW1lbnQpLCB0aGlzLkRBVEFfS0VZKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OO1xuICB9XG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIGBicy4ke3RoaXMuTkFNRX1gO1xuICB9XG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xuICB9XG4gIHN0YXRpYyBldmVudE5hbWUobmFtZSkge1xuICAgIHJldHVybiBgJHtuYW1lfSR7dGhpcy5FVkVOVF9LRVl9YDtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgZG9tL3NlbGVjdG9yLWVuZ2luZS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IGdldFNlbGVjdG9yID0gZWxlbWVudCA9PiB7XG4gIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXRhcmdldCcpO1xuICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcbiAgICBsZXQgaHJlZkF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cbiAgICAvLyBUaGUgb25seSB2YWxpZCBjb250ZW50IHRoYXQgY291bGQgZG91YmxlIGFzIGEgc2VsZWN0b3IgYXJlIElEcyBvciBjbGFzc2VzLFxuICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFwicmVhbFwiIFVSTCBpcyB1c2VkIGFzIHRoZSBzZWxlY3RvcixcbiAgICAvLyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2lsbCByaWdodGZ1bGx5IGNvbXBsYWluIGl0IGlzIGludmFsaWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcbiAgICBpZiAoIWhyZWZBdHRyaWJ1dGUgfHwgIWhyZWZBdHRyaWJ1dGUuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHJpYnV0ZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEp1c3QgaW4gY2FzZSBzb21lIENNUyBwdXRzIG91dCBhIGZ1bGwgVVJMIHdpdGggdGhlIGFuY2hvciBhcHBlbmRlZFxuICAgIGlmIChocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICBocmVmQXR0cmlidXRlID0gYCMke2hyZWZBdHRyaWJ1dGUuc3BsaXQoJyMnKVsxXX1gO1xuICAgIH1cbiAgICBzZWxlY3RvciA9IGhyZWZBdHRyaWJ1dGUgJiYgaHJlZkF0dHJpYnV0ZSAhPT0gJyMnID8gaHJlZkF0dHJpYnV0ZS50cmltKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiBzZWxlY3RvciA/IHNlbGVjdG9yLnNwbGl0KCcsJykubWFwKHNlbCA9PiBwYXJzZVNlbGVjdG9yKHNlbCkpLmpvaW4oJywnKSA6IG51bGw7XG59O1xuY29uc3QgU2VsZWN0b3JFbmdpbmUgPSB7XG4gIGZpbmQoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xuICB9LFxuICBmaW5kT25lKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG4gIH0sXG4gIGNoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xuICB9LFxuICBwYXJlbnRzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIHBhcmVudHMucHVzaChhbmNlc3Rvcik7XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xuICB9LFxuICBwcmV2KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIHdoaWxlIChwcmV2aW91cykge1xuICAgICAgaWYgKHByZXZpb3VzLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIC8vIFRPRE86IHRoaXMgaXMgbm93IHVudXNlZDsgcmVtb3ZlIGxhdGVyIGFsb25nIHdpdGggcHJldigpXG4gIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbmV4dCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gW25leHRdO1xuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICBjb25zdCBmb2N1c2FibGVzID0gWydhJywgJ2J1dHRvbicsICdpbnB1dCcsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnZGV0YWlscycsICdbdGFiaW5kZXhdJywgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJ10ubWFwKHNlbGVjdG9yID0+IGAke3NlbGVjdG9yfTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pYCkuam9pbignLCcpO1xuICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcbiAgfSxcbiAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvcikgOiBudWxsO1xuICB9LFxuICBnZXRNdWx0aXBsZUVsZW1lbnRzRnJvbVNlbGVjdG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgIHJldHVybiBzZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpIDogW107XG4gIH1cbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL2NvbXBvbmVudC1mdW5jdGlvbnMuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBlbmFibGVEaXNtaXNzVHJpZ2dlciA9IChjb21wb25lbnQsIG1ldGhvZCA9ICdoaWRlJykgPT4ge1xuICBjb25zdCBjbGlja0V2ZW50ID0gYGNsaWNrLmRpc21pc3Mke2NvbXBvbmVudC5FVkVOVF9LRVl9YDtcbiAgY29uc3QgbmFtZSA9IGNvbXBvbmVudC5OQU1FO1xuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIGNsaWNrRXZlbnQsIGBbZGF0YS1icy1kaXNtaXNzPVwiJHtuYW1lfVwiXWAsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtuYW1lfWApO1xuICAgIGNvbnN0IGluc3RhbmNlID0gY29tcG9uZW50LmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcblxuICAgIC8vIE1ldGhvZCBhcmd1bWVudCBpcyBsZWZ0LCBmb3IgQWxlcnQgYW5kIG9ubHksIGFzIGl0IGRvZXNuJ3QgaW1wbGVtZW50IHRoZSAnaGlkZScgbWV0aG9kXG4gICAgaW5zdGFuY2VbbWV0aG9kXSgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBhbGVydC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJGYgPSAnYWxlcnQnO1xuY29uc3QgREFUQV9LRVkkYSA9ICdicy5hbGVydCc7XG5jb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRhfWA7XG5jb25zdCBFVkVOVF9DTE9TRSA9IGBjbG9zZSR7RVZFTlRfS0VZJGJ9YDtcbmNvbnN0IEVWRU5UX0NMT1NFRCA9IGBjbG9zZWQke0VWRU5UX0tFWSRifWA7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ4ID0gJ3Nob3cnO1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBBbGVydCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSRmO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IGNsb3NlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRSk7XG4gICAgaWYgKGNsb3NlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDgpO1xuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkNSk7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCBpc0FuaW1hdGVkKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0VEKTtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IEFsZXJ0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG4gICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbmVuYWJsZURpc21pc3NUcmlnZ2VyKEFsZXJ0LCAnY2xvc2UnKTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQWxlcnQpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgYnV0dG9uLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkZSA9ICdidXR0b24nO1xuY29uc3QgREFUQV9LRVkkOSA9ICdicy5idXR0b24nO1xuY29uc3QgRVZFTlRfS0VZJGEgPSBgLiR7REFUQV9LRVkkOX1gO1xuY29uc3QgREFUQV9BUElfS0VZJDYgPSAnLmRhdGEtYXBpJztcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDMgPSAnYWN0aXZlJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiYnV0dG9uXCJdJztcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYgPSBgY2xpY2ske0VWRU5UX0tFWSRhfSR7REFUQV9BUElfS0VZJDZ9YDtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGU7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIC8vIFRvZ2dsZSBjbGFzcyBhbmQgc3luYyB0aGUgYGFyaWEtcHJlc3NlZGAgYXR0cmlidXRlIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYC50b2dnbGUoKWAgbWV0aG9kXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSQzKSk7XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgYnV0dG9uID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfREFUQV9UT0dHTEUkNSk7XG4gIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZShidXR0b24pO1xuICBkYXRhLnRvZ2dsZSgpO1xufSk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL3N3aXBlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkZCA9ICdzd2lwZSc7XG5jb25zdCBFVkVOVF9LRVkkOSA9ICcuYnMuc3dpcGUnO1xuY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfVE9VQ0hNT1ZFID0gYHRvdWNobW92ZSR7RVZFTlRfS0VZJDl9YDtcbmNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSQ5fWA7XG5jb25zdCBFVkVOVF9QT0lOVEVSVVAgPSBgcG9pbnRlcnVwJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbmNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcbmNvbnN0IENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCA9ICdwb2ludGVyLWV2ZW50JztcbmNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xuY29uc3QgRGVmYXVsdCRjID0ge1xuICBlbmRDYWxsYmFjazogbnVsbCxcbiAgbGVmdENhbGxiYWNrOiBudWxsLFxuICByaWdodENhbGxiYWNrOiBudWxsXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkYyA9IHtcbiAgZW5kQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICBsZWZ0Q2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICByaWdodENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgU3dpcGUgZXh0ZW5kcyBDb25maWcge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIGlmICghZWxlbWVudCB8fCAhU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9kZWx0YVggPSAwO1xuICAgIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50KTtcbiAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCRjO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJGM7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGQ7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWSQ5KTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX3N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cykge1xuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgfVxuICB9XG4gIF9lbmQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVN3aXBlKCk7XG4gICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuZW5kQ2FsbGJhY2spO1xuICB9XG4gIF9tb3ZlKGV2ZW50KSB7XG4gICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5fZGVsdGFYO1xuICB9XG4gIF9oYW5kbGVTd2lwZSgpIHtcbiAgICBjb25zdCBhYnNEZWx0YVggPSBNYXRoLmFicyh0aGlzLl9kZWx0YVgpO1xuICAgIGlmIChhYnNEZWx0YVggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFic0RlbHRhWCAvIHRoaXMuX2RlbHRhWDtcbiAgICB0aGlzLl9kZWx0YVggPSAwO1xuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV4ZWN1dGUoZGlyZWN0aW9uID4gMCA/IHRoaXMuX2NvbmZpZy5yaWdodENhbGxiYWNrIDogdGhpcy5fY29uZmlnLmxlZnRDYWxsYmFjayk7XG4gIH1cbiAgX2luaXRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUkRPV04sIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IHRoaXMuX21vdmUoZXZlbnQpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSEVORCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XG4gICAgfVxuICB9XG4gIF9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzICYmIChldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1BFTiB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1RPVUNIKTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBjYXJvdXNlbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJGMgPSAnY2Fyb3VzZWwnO1xuY29uc3QgREFUQV9LRVkkOCA9ICdicy5jYXJvdXNlbCc7XG5jb25zdCBFVkVOVF9LRVkkOCA9IGAuJHtEQVRBX0tFWSQ4fWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xuY29uc3QgQVJST1dfTEVGVF9LRVkkMSA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFRfS0VZJDEgPSAnQXJyb3dSaWdodCc7XG5jb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcblxuY29uc3QgT1JERVJfTkVYVCA9ICduZXh0JztcbmNvbnN0IE9SREVSX1BSRVYgPSAncHJldic7XG5jb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbmNvbnN0IERJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5jb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX1NMSUQgPSBgc2xpZCR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX0tFWURPV04kMSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfTU9VU0VFTlRFUiQxID0gYG1vdXNlZW50ZXIke0VWRU5UX0tFWSQ4fWA7XG5jb25zdCBFVkVOVF9NT1VTRUxFQVZFJDEgPSBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX0RSQUdfU1RBUlQgPSBgZHJhZ3N0YXJ0JHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQzID0gYGxvYWQke0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUgPSBgY2xpY2ske0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcbmNvbnN0IENMQVNTX05BTUVfQ0FST1VTRUwgPSAnY2Fyb3VzZWwnO1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMiA9ICdhY3RpdmUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSc7XG5jb25zdCBDTEFTU19OQU1FX0VORCA9ICdjYXJvdXNlbC1pdGVtLWVuZCc7XG5jb25zdCBDTEFTU19OQU1FX1NUQVJUID0gJ2Nhcm91c2VsLWl0ZW0tc3RhcnQnO1xuY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCc7XG5jb25zdCBDTEFTU19OQU1FX1BSRVYgPSAnY2Fyb3VzZWwtaXRlbS1wcmV2JztcbmNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJztcbmNvbnN0IFNFTEVDVE9SX0lURU0gPSAnLmNhcm91c2VsLWl0ZW0nO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFX0lURU0gPSBTRUxFQ1RPUl9BQ1RJVkUgKyBTRUxFQ1RPUl9JVEVNO1xuY29uc3QgU0VMRUNUT1JfSVRFTV9JTUcgPSAnLmNhcm91c2VsLWl0ZW0gaW1nJztcbmNvbnN0IFNFTEVDVE9SX0lORElDQVRPUlMgPSAnLmNhcm91c2VsLWluZGljYXRvcnMnO1xuY29uc3QgU0VMRUNUT1JfREFUQV9TTElERSA9ICdbZGF0YS1icy1zbGlkZV0sIFtkYXRhLWJzLXNsaWRlLXRvXSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1JJREUgPSAnW2RhdGEtYnMtcmlkZT1cImNhcm91c2VsXCJdJztcbmNvbnN0IEtFWV9UT19ESVJFQ1RJT04gPSB7XG4gIFtBUlJPV19MRUZUX0tFWSQxXTogRElSRUNUSU9OX1JJR0hULFxuICBbQVJST1dfUklHSFRfS0VZJDFdOiBESVJFQ1RJT05fTEVGVFxufTtcbmNvbnN0IERlZmF1bHQkYiA9IHtcbiAgaW50ZXJ2YWw6IDUwMDAsXG4gIGtleWJvYXJkOiB0cnVlLFxuICBwYXVzZTogJ2hvdmVyJyxcbiAgcmlkZTogZmFsc2UsXG4gIHRvdWNoOiB0cnVlLFxuICB3cmFwOiB0cnVlXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkYiA9IHtcbiAgaW50ZXJ2YWw6ICcobnVtYmVyfGJvb2xlYW4pJyxcbiAgLy8gVE9ETzp2NiByZW1vdmUgYm9vbGVhbiBzdXBwb3J0XG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gIHBhdXNlOiAnKHN0cmluZ3xib29sZWFuKScsXG4gIHJpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgdG91Y2g6ICdib29sZWFuJyxcbiAgd3JhcDogJ2Jvb2xlYW4nXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRvdWNoVGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBudWxsO1xuICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTkRJQ0FUT1JTLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIGlmICh0aGlzLl9jb25maWcucmlkZSA9PT0gQ0xBU1NfTkFNRV9DQVJPVVNFTCkge1xuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JGI7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkYjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkYztcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBuZXh0KCkge1xuICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xuICB9XG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAvLyBGSVhNRSBUT0RPIHVzZSBgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlYFxuICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcbiAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXG4gICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiYgaXNWaXNpYmxlKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgcHJldigpIHtcbiAgICB0aGlzLl9zbGlkZShPUkRFUl9QUkVWKTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xuICB9XG4gIGN5Y2xlKCkge1xuICAgIHRoaXMuX2NsZWFySW50ZXJ2YWwoKTtcbiAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpO1xuICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5uZXh0V2hlblZpc2libGUoKSwgdGhpcy5fY29uZmlnLmludGVydmFsKTtcbiAgfVxuICBfbWF5YmVFbmFibGVDeWNsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5yaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy5jeWNsZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jeWNsZSgpO1xuICB9XG4gIHRvKGluZGV4KSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtcygpO1xuICAgIGlmIChpbmRleCA+IGl0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy50byhpbmRleCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9nZXRBY3RpdmUoKSk7XG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmRlciA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcbiAgICB0aGlzLl9zbGlkZShvcmRlciwgaXRlbXNbaW5kZXhdKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9zd2lwZUhlbHBlcikge1xuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgIGNvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSBjb25maWcuaW50ZXJ2YWw7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04kMSwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VFTlRFUiQxLCAoKSA9PiB0aGlzLnBhdXNlKCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUkMSwgKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCAmJiBTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG4gIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgaW1nIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTV9JTUcsIHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24oaW1nLCBFVkVOVF9EUkFHX1NUQVJULCBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9XG4gICAgY29uc3QgZW5kQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlICE9PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgLy8gcGFydCBvZiB0aGUgbW91c2UgY29tcGF0aWJpbGl0eSBldmVudHMgb24gZmlyc3QgdGFwIC0gdGhlIGNhcm91c2VsXG4gICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xuICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgIC8vIChhcyBpZiBpdCdzIHRoZSBzZWNvbmQgdGltZSB3ZSB0YXAgb24gaXQsIG1vdXNlZW50ZXIgY29tcGF0IGV2ZW50XG4gICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XG4gICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcblxuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgaWYgKHRoaXMudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpLCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUICsgdGhpcy5fY29uZmlnLmludGVydmFsKTtcbiAgICB9O1xuICAgIGNvbnN0IHN3aXBlQ29uZmlnID0ge1xuICAgICAgbGVmdENhbGxiYWNrOiAoKSA9PiB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKERJUkVDVElPTl9MRUZUKSksXG4gICAgICByaWdodENhbGxiYWNrOiAoKSA9PiB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKERJUkVDVElPTl9SSUdIVCkpLFxuICAgICAgZW5kQ2FsbGJhY2s6IGVuZENhbGxCYWNrXG4gICAgfTtcbiAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG5ldyBTd2lwZSh0aGlzLl9lbGVtZW50LCBzd2lwZUNvbmZpZyk7XG4gIH1cbiAgX2tleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlyZWN0aW9uID0gS0VZX1RPX0RJUkVDVElPTltldmVudC5rZXldO1xuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikpO1xuICAgIH1cbiAgfVxuICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbXMoKS5pbmRleE9mKGVsZW1lbnQpO1xuICB9XG4gIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuICAgIGFjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgIGFjdGl2ZUluZGljYXRvci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpO1xuICAgIGNvbnN0IG5ld0FjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoYFtkYXRhLWJzLXNsaWRlLXRvPVwiJHtpbmRleH1cIl1gLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XG4gICAgaWYgKG5ld0FjdGl2ZUluZGljYXRvcikge1xuICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICBuZXdBY3RpdmVJbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgdGhpcy5fZ2V0QWN0aXZlKCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRJbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1pbnRlcnZhbCcpLCAxMCk7XG4gICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gZWxlbWVudEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWw7XG4gIH1cbiAgX3NsaWRlKG9yZGVyLCBlbGVtZW50ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZSgpO1xuICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUO1xuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRJdGVtcygpLCBhY3RpdmVFbGVtZW50LCBpc05leHQsIHRoaXMuX2NvbmZpZy53cmFwKTtcbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudCk7XG4gICAgY29uc3QgdHJpZ2dlckV2ZW50ID0gZXZlbnROYW1lID0+IHtcbiAgICAgIHJldHVybiBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBldmVudE5hbWUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihvcmRlciksXG4gICAgICAgIGZyb206IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KSxcbiAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2xpZGVFdmVudCA9IHRyaWdnZXJFdmVudChFVkVOVF9TTElERSk7XG4gICAgaWYgKHNsaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XG4gICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcbiAgICAgIC8vIFRPRE86IGNoYW5nZSB0ZXN0cyB0aGF0IHVzZSBlbXB0eSBkaXZzIHRvIGF2b2lkIHRoaXMgY2hlY2tcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG4gICAgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChuZXh0RWxlbWVudEluZGV4KTtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgY29uc3QgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX1NUQVJUIDogQ0xBU1NfTkFNRV9FTkQ7XG4gICAgY29uc3Qgb3JkZXJDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX05FWFQgOiBDTEFTU19OQU1FX1BSRVY7XG4gICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChvcmRlckNsYXNzTmFtZSk7XG4gICAgcmVmbG93KG5leHRFbGVtZW50KTtcbiAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGRpcmVjdGlvbmFsQ2xhc3NOYW1lLCBvcmRlckNsYXNzTmFtZSk7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgIHRyaWdnZXJFdmVudChFVkVOVF9TTElEKTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgYWN0aXZlRWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICB9XG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NMSURFKTtcbiAgfVxuICBfZ2V0QWN0aXZlKCkge1xuICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfZ2V0SXRlbXMoKSB7XG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2NsZWFySW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGlzUlRMKCkpIHtcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVY7XG4gIH1cbiAgX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpIHtcbiAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGEudG8oY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSwgU0VMRUNUT1JfREFUQV9TTElERSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XG4gIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGNvbnN0IGNhcm91c2VsID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKTtcbiAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICBjYXJvdXNlbC50byhzbGlkZUluZGV4KTtcbiAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLCAnc2xpZGUnKSA9PT0gJ25leHQnKSB7XG4gICAgY2Fyb3VzZWwubmV4dCgpO1xuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNhcm91c2VsLnByZXYoKTtcbiAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbn0pO1xuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQzLCAoKSA9PiB7XG4gIGNvbnN0IGNhcm91c2VscyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9SSURFKTtcbiAgZm9yIChjb25zdCBjYXJvdXNlbCBvZiBjYXJvdXNlbHMpIHtcbiAgICBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKGNhcm91c2VsKTtcbiAgfVxufSk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKENhcm91c2VsKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkYiA9ICdjb2xsYXBzZSc7XG5jb25zdCBEQVRBX0tFWSQ3ID0gJ2JzLmNvbGxhcHNlJztcbmNvbnN0IEVWRU5UX0tFWSQ3ID0gYC4ke0RBVEFfS0VZJDd9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFVkVOVF9TSE9XJDYgPSBgc2hvdyR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDYgPSBgc2hvd24ke0VWRU5UX0tFWSQ3fWA7XG5jb25zdCBFVkVOVF9ISURFJDYgPSBgaGlkZSR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQ2ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQgPSBgY2xpY2ske0VWRU5UX0tFWSQ3fSR7REFUQV9BUElfS0VZJDR9YDtcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ3ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNJTkcgPSAnY29sbGFwc2luZyc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xuY29uc3QgQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4gPSBgOnNjb3BlIC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9IC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9YDtcbmNvbnN0IENMQVNTX05BTUVfSE9SSVpPTlRBTCA9ICdjb2xsYXBzZS1ob3Jpem9udGFsJztcbmNvbnN0IFdJRFRIID0gJ3dpZHRoJztcbmNvbnN0IEhFSUdIVCA9ICdoZWlnaHQnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFUyA9ICcuY29sbGFwc2Uuc2hvdywgLmNvbGxhcHNlLmNvbGxhcHNpbmcnO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCA9ICdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XG5jb25zdCBEZWZhdWx0JGEgPSB7XG4gIHBhcmVudDogbnVsbCxcbiAgdG9nZ2xlOiB0cnVlXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkYSA9IHtcbiAgcGFyZW50OiAnKG51bGx8ZWxlbWVudCknLFxuICB0b2dnbGU6ICdib29sZWFuJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQ29sbGFwc2UgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICBjb25zdCB0b2dnbGVMaXN0ID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0KTtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdG9nZ2xlTGlzdCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBTZWxlY3RvckVuZ2luZS5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pO1xuICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZpbHRlcihmb3VuZEVsZW1lbnQgPT4gZm91bmRFbGVtZW50ID09PSB0aGlzLl9lbGVtZW50KTtcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCAmJiBmaWx0ZXJFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCk7XG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0aGlzLl9pc1Nob3duKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCRhO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJGE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGI7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYWN0aXZlQ2hpbGRyZW4gPSBbXTtcblxuICAgIC8vIGZpbmQgYWN0aXZlIGNoaWxkcmVuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIGFjdGl2ZUNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0FDVElWRVMpLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQpLm1hcChlbGVtZW50ID0+IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xuICAgICAgICB0b2dnbGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmVDaGlsZHJlbi5sZW5ndGggJiYgYWN0aXZlQ2hpbGRyZW5bMF0uX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ2KTtcbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWN0aXZlSW5zdGFuY2Ugb2YgYWN0aXZlQ2hpbGRyZW4pIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlLmhpZGUoKTtcbiAgICB9XG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDA7XG4gICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdHJ1ZSk7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ2KTtcbiAgICB9O1xuICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGBzY3JvbGwke2NhcGl0YWxpemVkRGltZW5zaW9ufWA7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNik7XG4gICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgO1xuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0aGlzLl90cmlnZ2VyQXJyYXkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRyaWdnZXIpO1xuICAgICAgaWYgKGVsZW1lbnQgJiYgIXRoaXMuX2lzU2hvd24oZWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ2KTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfaXNTaG93bihlbGVtZW50ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNyk7XG4gIH1cbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgY29uZmlnLnBhcmVudCA9IGdldEVsZW1lbnQoY29uZmlnLnBhcmVudCk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfZ2V0RGltZW5zaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0hPUklaT05UQUwpID8gV0lEVEggOiBIRUlHSFQ7XG4gIH1cbiAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlbGVtZW50XSwgdGhpcy5faXNTaG93bihzZWxlY3RlZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kKENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOLCB0aGlzLl9jb25maWcucGFyZW50KTtcbiAgICAvLyByZW1vdmUgY2hpbGRyZW4gaWYgZ3JlYXRlciBkZXB0aFxuICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9jb25maWcucGFyZW50KS5maWx0ZXIoZWxlbWVudCA9PiAhY2hpbGRyZW4uaW5jbHVkZXMoZWxlbWVudCkpO1xuICB9XG4gIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModHJpZ2dlckFycmF5LCBpc09wZW4pIHtcbiAgICBpZiAoIXRyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJBcnJheSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICBjb25zdCBfY29uZmlnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBfY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciA8YT4gZWxlbWVudHMgKHdoaWNoIGNoYW5nZSB0aGUgVVJMKSBub3QgaW5zaWRlIHRoZSBjb2xsYXBzaWJsZSBlbGVtZW50XG4gIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09ICdBJykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IodGhpcykpIHtcbiAgICBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIHtcbiAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICB9KS50b2dnbGUoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKENvbGxhcHNlKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGRyb3Bkb3duLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkYSA9ICdkcm9wZG93bic7XG5jb25zdCBEQVRBX0tFWSQ2ID0gJ2JzLmRyb3Bkb3duJztcbmNvbnN0IEVWRU5UX0tFWSQ2ID0gYC4ke0RBVEFfS0VZJDZ9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFU0NBUEVfS0VZJDIgPSAnRXNjYXBlJztcbmNvbnN0IFRBQl9LRVkkMSA9ICdUYWInO1xuY29uc3QgQVJST1dfVVBfS0VZJDEgPSAnQXJyb3dVcCc7XG5jb25zdCBBUlJPV19ET1dOX0tFWSQxID0gJ0Fycm93RG93bic7XG5jb25zdCBSSUdIVF9NT1VTRV9CVVRUT04gPSAyOyAvLyBNb3VzZUV2ZW50LmJ1dHRvbiB2YWx1ZSBmb3IgdGhlIHNlY29uZGFyeSBidXR0b24sIHVzdWFsbHkgdGhlIHJpZ2h0IGJ1dHRvblxuXG5jb25zdCBFVkVOVF9ISURFJDUgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX1NIT1ckNSA9IGBzaG93JHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfU0hPV04kNSA9IGBzaG93biR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMgPSBgY2xpY2ske0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX0tFWURPV05fREFUQV9BUEkgPSBga2V5ZG93biR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xuY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ2ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJztcbmNvbnN0IENMQVNTX05BTUVfRFJPUEVORCA9ICdkcm9wZW5kJztcbmNvbnN0IENMQVNTX05BTUVfRFJPUFNUQVJUID0gJ2Ryb3BzdGFydCc7XG5jb25zdCBDTEFTU19OQU1FX0RST1BVUF9DRU5URVIgPSAnZHJvcHVwLWNlbnRlcic7XG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiA9ICdkcm9wZG93bi1jZW50ZXInO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMyA9ICdbZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiXTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTiA9IGAke1NFTEVDVE9SX0RBVEFfVE9HR0xFJDN9LiR7Q0xBU1NfTkFNRV9TSE9XJDZ9YDtcbmNvbnN0IFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuY29uc3QgU0VMRUNUT1JfTkFWQkFSID0gJy5uYXZiYXInO1xuY29uc3QgU0VMRUNUT1JfTkFWQkFSX05BViA9ICcubmF2YmFyLW5hdic7XG5jb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbmNvbnN0IFBMQUNFTUVOVF9UT1AgPSBpc1JUTCgpID8gJ3RvcC1lbmQnIDogJ3RvcC1zdGFydCc7XG5jb25zdCBQTEFDRU1FTlRfVE9QRU5EID0gaXNSVEwoKSA/ICd0b3Atc3RhcnQnIDogJ3RvcC1lbmQnO1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcbmNvbnN0IFBMQUNFTUVOVF9CT1RUT01FTkQgPSBpc1JUTCgpID8gJ2JvdHRvbS1zdGFydCcgOiAnYm90dG9tLWVuZCc7XG5jb25zdCBQTEFDRU1FTlRfUklHSFQgPSBpc1JUTCgpID8gJ2xlZnQtc3RhcnQnIDogJ3JpZ2h0LXN0YXJ0JztcbmNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XG5jb25zdCBQTEFDRU1FTlRfVE9QQ0VOVEVSID0gJ3RvcCc7XG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSID0gJ2JvdHRvbSc7XG5jb25zdCBEZWZhdWx0JDkgPSB7XG4gIGF1dG9DbG9zZTogdHJ1ZSxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICBkaXNwbGF5OiAnZHluYW1pYycsXG4gIG9mZnNldDogWzAsIDJdLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIHJlZmVyZW5jZTogJ3RvZ2dsZSdcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ5ID0ge1xuICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgZGlzcGxheTogJ3N0cmluZycsXG4gIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXG4gIHJlZmVyZW5jZTogJyhzdHJpbmd8ZWxlbWVudHxvYmplY3QpJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTsgLy8gZHJvcGRvd24gd3JhcHBlclxuICAgIC8vIFRPRE86IHY2IHJldmVydCAjMzcwMTEgJiBjaGFuZ2UgbWFya3VwIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMy9mb3Jtcy9pbnB1dC1ncm91cC9cbiAgICB0aGlzLl9tZW51ID0gU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXSB8fCBTZWxlY3RvckVuZ2luZS5wcmV2KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTUVOVSwgdGhpcy5fcGFyZW50KTtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkOTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ5O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSRhO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH07XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3JlYXRlUG9wcGVyKCk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIXRoaXMuX3BhcmVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUl9OQVYpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDUsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKTtcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNSwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAvLyBFeHBsaWNpdGx5IHJldHVybiBmb2N1cyB0byB0aGUgdHJpZ2dlciBlbGVtZW50XG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICB9XG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0gc3VwZXIuX2dldENvbmZpZyhjb25maWcpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFBvcHBlciB2aXJ0dWFsIGVsZW1lbnRzIHJlcXVpcmUgYSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbWV0aG9kXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke05BTUUkYS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfY3JlYXRlUG9wcGVyKCkge1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YyLyknKTtcbiAgICB9XG4gICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgIGlmICh0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAncGFyZW50Jykge1xuICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX3BhcmVudDtcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xuICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGdldEVsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlO1xuICAgIH1cbiAgICBjb25zdCBwb3BwZXJDb25maWcgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKTtcbiAgICB0aGlzLl9wb3BwZXIgPSBQb3BwZXIuY3JlYXRlUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XG4gIH1cbiAgX2lzU2hvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgfVxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0IHBhcmVudERyb3Bkb3duID0gdGhpcy5fcGFyZW50O1xuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVDtcbiAgICB9XG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfTEVGVDtcbiAgICB9XG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUF9DRU5URVIpKSB7XG4gICAgICByZXR1cm4gUExBQ0VNRU5UX1RPUENFTlRFUjtcbiAgICB9XG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gdHJpbSB0aGUgdmFsdWUgYmVjYXVzZSBjdXN0b20gcHJvcGVydGllcyBjYW4gYWxzbyBpbmNsdWRlIHNwYWNlc1xuICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQKSkge1xuICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX1RPUEVORCA6IFBMQUNFTUVOVF9UT1A7XG4gICAgfVxuICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9CT1RUT01FTkQgOiBQTEFDRU1FTlRfQk9UVE9NO1xuICB9XG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVIpICE9PSBudWxsO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0XG4gICAgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfTtcblxuICAgIC8vIERpc2FibGUgUG9wcGVyIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheSBvciBEcm9wZG93biBpcyBpbiBOYXZiYXJcbiAgICBpZiAodGhpcy5faW5OYXZiYXIgfHwgdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XG4gICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInLCAnc3RhdGljJyk7IC8vIFRPRE86IHY2IHJlbW92ZVxuICAgICAgZGVmYXVsdEJzUG9wcGVyQ29uZmlnLm1vZGlmaWVycyA9IFt7XG4gICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgIC4uLmV4ZWN1dGUodGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZywgW3VuZGVmaW5lZCwgZGVmYXVsdEJzUG9wcGVyQ29uZmlnXSlcbiAgICB9O1xuICB9XG4gIF9zZWxlY3RNZW51SXRlbSh7XG4gICAga2V5LFxuICAgIHRhcmdldFxuICB9KSB7XG4gICAgY29uc3QgaXRlbXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMsIHRoaXMuX21lbnUpLmZpbHRlcihlbGVtZW50ID0+IGlzVmlzaWJsZShlbGVtZW50KSk7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiB0YXJnZXQgaXNuJ3QgaW5jbHVkZWQgaW4gaXRlbXMgKGUuZy4gd2hlbiBleHBhbmRpbmcgdGhlIGRyb3Bkb3duKVxuICAgIC8vIGFsbG93IGN5Y2xpbmcgdG8gZ2V0IHRoZSBsYXN0IGl0ZW0gaW4gY2FzZSBrZXkgZXF1YWxzIEFSUk9XX1VQX0tFWVxuICAgIGdldE5leHRBY3RpdmVFbGVtZW50KGl0ZW1zLCB0YXJnZXQsIGtleSA9PT0gQVJST1dfRE9XTl9LRVkkMSwgIWl0ZW1zLmluY2x1ZGVzKHRhcmdldCkpLmZvY3VzKCk7XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG4gICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY2xlYXJNZW51cyhldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gPT09IFJJR0hUX01PVVNFX0JVVFRPTiB8fCBldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSAhPT0gVEFCX0tFWSQxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wZW5Ub2dnbGVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTik7XG4gICAgZm9yIChjb25zdCB0b2dnbGUgb2Ygb3BlblRvZ2dsZXMpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBEcm9wZG93bi5nZXRJbnN0YW5jZSh0b2dnbGUpO1xuICAgICAgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICBjb25zdCBpc01lbnVUYXJnZXQgPSBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fbWVudSk7XG4gICAgICBpZiAoY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX2VsZW1lbnQpIHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdpbnNpZGUnICYmICFpc01lbnVUYXJnZXQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ291dHNpZGUnICYmIGlzTWVudVRhcmdldCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGFiIG5hdmlnYXRpb24gdGhyb3VnaCB0aGUgZHJvcGRvd24gbWVudSBvciBldmVudHMgZnJvbSBjb250YWluZWQgaW5wdXRzIHNob3VsZG4ndCBjbG9zZSB0aGUgbWVudVxuICAgICAgaWYgKGNvbnRleHQuX21lbnUuY29udGFpbnMoZXZlbnQudGFyZ2V0KSAmJiAoZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgPT09IFRBQl9LRVkkMSB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogY29udGV4dC5fZWxlbWVudFxuICAgICAgfTtcbiAgICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQuY2xpY2tFdmVudCA9IGV2ZW50O1xuICAgICAgfVxuICAgICAgY29udGV4dC5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgLy8gSWYgbm90IGFuIFVQIHwgRE9XTiB8IEVTQ0FQRSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vIElmIGlucHV0L3RleHRhcmVhICYmIGlmIGtleSBpcyBvdGhlciB0aGFuIEVTQ0FQRSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG5cbiAgICBjb25zdCBpc0lucHV0ID0gL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSk7XG4gICAgY29uc3QgaXNFc2NhcGVFdmVudCA9IGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQyO1xuICAgIGNvbnN0IGlzVXBPckRvd25FdmVudCA9IFtBUlJPV19VUF9LRVkkMSwgQVJST1dfRE9XTl9LRVkkMV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcbiAgICBpZiAoIWlzVXBPckRvd25FdmVudCAmJiAhaXNFc2NhcGVFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNJbnB1dCAmJiAhaXNFc2NhcGVFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gVE9ETzogdjYgcmV2ZXJ0ICMzNzAxMSAmIGNoYW5nZSBtYXJrdXAgaHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNS4zL2Zvcm1zL2lucHV0LWdyb3VwL1xuICAgIGNvbnN0IGdldFRvZ2dsZUJ1dHRvbiA9IHRoaXMubWF0Y2hlcyhTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKSA/IHRoaXMgOiBTZWxlY3RvckVuZ2luZS5wcmV2KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpWzBdIHx8IFNlbGVjdG9yRW5naW5lLm5leHQodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBldmVudC5kZWxlZ2F0ZVRhcmdldC5wYXJlbnROb2RlKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UoZ2V0VG9nZ2xlQnV0dG9uKTtcbiAgICBpZiAoaXNVcE9yRG93bkV2ZW50KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICAgIGluc3RhbmNlLl9zZWxlY3RNZW51SXRlbShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5faXNTaG93bigpKSB7XG4gICAgICAvLyBlbHNlIGlzIGVzY2FwZSBhbmQgd2UgY2hlY2sgaWYgaXQgaXMgc2hvd25cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgZ2V0VG9nZ2xlQnV0dG9uLmZvY3VzKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIERyb3Bkb3duLmNsZWFyTWVudXMpO1xuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlVUF9EQVRBX0FQSSwgRHJvcGRvd24uY2xlYXJNZW51cyk7XG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnRvZ2dsZSgpO1xufSk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKERyb3Bkb3duKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvYmFja2Ryb3AuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQ5ID0gJ2JhY2tkcm9wJztcbmNvbnN0IENMQVNTX05BTUVfRkFERSQ0ID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDUgPSAnc2hvdyc7XG5jb25zdCBFVkVOVF9NT1VTRURPV04gPSBgbW91c2Vkb3duLmJzLiR7TkFNRSQ5fWA7XG5jb25zdCBEZWZhdWx0JDggPSB7XG4gIGNsYXNzTmFtZTogJ21vZGFsLWJhY2tkcm9wJyxcbiAgY2xpY2tDYWxsYmFjazogbnVsbCxcbiAgaXNBbmltYXRlZDogZmFsc2UsXG4gIGlzVmlzaWJsZTogdHJ1ZSxcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cbiAgcm9vdEVsZW1lbnQ6ICdib2R5JyAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkOCA9IHtcbiAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgY2xpY2tDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXG4gIGlzQW5pbWF0ZWQ6ICdib29sZWFuJyxcbiAgaXNWaXNpYmxlOiAnYm9vbGVhbicsXG4gIHJvb3RFbGVtZW50OiAnKGVsZW1lbnR8c3RyaW5nKSdcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEJhY2tkcm9wIGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ4O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDg7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDk7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgc2hvdyhjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZCgpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XG4gICAgICByZWZsb3coZWxlbWVudCk7XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNSk7XG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxuICBoaWRlKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDUpO1xuICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTik7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9nZXRFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgY29uc3QgYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGJhY2tkcm9wLmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWU7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkNCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50ID0gYmFja2Ryb3A7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgIC8vIHVzZSBnZXRFbGVtZW50KCkgd2l0aCB0aGUgZGVmYXVsdCBcImJvZHlcIiB0byBnZXQgYSBmcmVzaCBFbGVtZW50IG9uIGVhY2ggaW5zdGFudGlhdGlvblxuICAgIGNvbmZpZy5yb290RWxlbWVudCA9IGdldEVsZW1lbnQoY29uZmlnLnJvb3RFbGVtZW50KTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9hcHBlbmQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQXBwZW5kZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcbiAgICB0aGlzLl9jb25maWcucm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCBFVkVOVF9NT1VTRURPV04sICgpID0+IHtcbiAgICAgIGV4ZWN1dGUodGhpcy5fY29uZmlnLmNsaWNrQ2FsbGJhY2spO1xuICAgIH0pO1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSB0cnVlO1xuICB9XG4gIF9lbXVsYXRlQW5pbWF0aW9uKGNhbGxiYWNrKSB7XG4gICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgdGhpcy5fZ2V0RWxlbWVudCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCk7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvZm9jdXN0cmFwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkOCA9ICdmb2N1c3RyYXAnO1xuY29uc3QgREFUQV9LRVkkNSA9ICdicy5mb2N1c3RyYXAnO1xuY29uc3QgRVZFTlRfS0VZJDUgPSBgLiR7REFUQV9LRVkkNX1gO1xuY29uc3QgRVZFTlRfRk9DVVNJTiQyID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX1RBQiA9IGBrZXlkb3duLnRhYiR7RVZFTlRfS0VZJDV9YDtcbmNvbnN0IFRBQl9LRVkgPSAnVGFiJztcbmNvbnN0IFRBQl9OQVZfRk9SV0FSRCA9ICdmb3J3YXJkJztcbmNvbnN0IFRBQl9OQVZfQkFDS1dBUkQgPSAnYmFja3dhcmQnO1xuY29uc3QgRGVmYXVsdCQ3ID0ge1xuICBhdXRvZm9jdXM6IHRydWUsXG4gIHRyYXBFbGVtZW50OiBudWxsIC8vIFRoZSBlbGVtZW50IHRvIHRyYXAgZm9jdXMgaW5zaWRlIG9mXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkNyA9IHtcbiAgYXV0b2ZvY3VzOiAnYm9vbGVhbicsXG4gIHRyYXBFbGVtZW50OiAnZWxlbWVudCdcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEZvY3VzVHJhcCBleHRlbmRzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gbnVsbDtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDc7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkNztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkODtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBhY3RpdmF0ZSgpIHtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hdXRvZm9jdXMpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy50cmFwRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNSk7IC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQyLCBldmVudCA9PiB0aGlzLl9oYW5kbGVGb2N1c2luKGV2ZW50KSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX1RBQiwgZXZlbnQgPT4gdGhpcy5faGFuZGxlS2V5ZG93bihldmVudCkpO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgfVxuICBkZWFjdGl2YXRlKCkge1xuICAgIGlmICghdGhpcy5faXNBY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNSk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9oYW5kbGVGb2N1c2luKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhcEVsZW1lbnRcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IGRvY3VtZW50IHx8IGV2ZW50LnRhcmdldCA9PT0gdHJhcEVsZW1lbnQgfHwgdHJhcEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IFNlbGVjdG9yRW5naW5lLmZvY3VzYWJsZUNoaWxkcmVuKHRyYXBFbGVtZW50KTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0cmFwRWxlbWVudC5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9PT0gVEFCX05BVl9CQUNLV0FSRCkge1xuICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHNbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5ICE9PSBUQUJfS0VZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBldmVudC5zaGlmdEtleSA/IFRBQl9OQVZfQkFDS1dBUkQgOiBUQUJfTkFWX0ZPUldBUkQ7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvc2Nyb2xsQmFyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XG5jb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XG5jb25zdCBQUk9QRVJUWV9QQURESU5HID0gJ3BhZGRpbmctcmlnaHQnO1xuY29uc3QgUFJPUEVSVFlfTUFSR0lOID0gJ21hcmdpbi1yaWdodCc7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFNjcm9sbEJhckhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGdldFdpZHRoKCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvaW5uZXJXaWR0aCN1c2FnZV9ub3Rlc1xuICAgIGNvbnN0IGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnRXaWR0aCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKTtcbiAgICAvLyBnaXZlIHBhZGRpbmcgdG8gZWxlbWVudCB0byBiYWxhbmNlIHRoZSBoaWRkZW4gc2Nyb2xsYmFyIHdpZHRoXG4gICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcbiAgICAvLyB0cmljazogV2UgYWRqdXN0IHBvc2l0aXZlIHBhZGRpbmdSaWdodCBhbmQgbmVnYXRpdmUgbWFyZ2luUmlnaHQgdG8gc3RpY2t5LXRvcCBlbGVtZW50cyB0byBrZWVwIHNob3dpbmcgZnVsbHdpZHRoXG4gICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gd2lkdGgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HKTtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsIFBST1BFUlRZX1BBRERJTkcpO1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTik7XG4gIH1cbiAgaXNPdmVyZmxvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIH1cbiAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxiYXJXaWR0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZWRWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIGAke2NhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpfXB4YCk7XG4gICAgfTtcbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XG4gIH1cbiAgX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpIHtcbiAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IGVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KTtcbiAgICBpZiAoYWN0dWFsVmFsdWUpIHtcbiAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSwgYWN0dWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wZXJ0eSkge1xuICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgdmFsdWUgaXMgYG51bGxgOyB0aGUgdmFsdWUgY2FuIGFsc28gYmUgemVyb1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIHZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcbiAgfVxuICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgY2FsbEJhY2spIHtcbiAgICBpZiAoaXNFbGVtZW50KHNlbGVjdG9yKSkge1xuICAgICAgY2FsbEJhY2soc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlbCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgY2FsbEJhY2soc2VsKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIG1vZGFsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkNyA9ICdtb2RhbCc7XG5jb25zdCBEQVRBX0tFWSQ0ID0gJ2JzLm1vZGFsJztcbmNvbnN0IEVWRU5UX0tFWSQ0ID0gYC4ke0RBVEFfS0VZJDR9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFU0NBUEVfS0VZJDEgPSAnRXNjYXBlJztcbmNvbnN0IEVWRU5UX0hJREUkNCA9IGBoaWRlJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQkMSA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfSElEREVOJDQgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfU0hPVyQ0ID0gYHNob3cke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfUkVTSVpFJDEgPSBgcmVzaXplJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MkMSA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQyID0gYGNsaWNrJHtFVkVOVF9LRVkkNH0ke0RBVEFfQVBJX0tFWSQyfWA7XG5jb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMyA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ0ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcbmNvbnN0IE9QRU5fU0VMRUNUT1IkMSA9ICcubW9kYWwuc2hvdyc7XG5jb25zdCBTRUxFQ1RPUl9ESUFMT0cgPSAnLm1vZGFsLWRpYWxvZyc7XG5jb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIgPSAnW2RhdGEtYnMtdG9nZ2xlPVwibW9kYWxcIl0nO1xuY29uc3QgRGVmYXVsdCQ2ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAgZm9jdXM6IHRydWUsXG4gIGtleWJvYXJkOiB0cnVlXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkNiA9IHtcbiAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgZm9jdXM6ICdib29sZWFuJyxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgTW9kYWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICB0aGlzLl9kaWFsb2cgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RJQUxPRywgdGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcbiAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBTY3JvbGxCYXJIZWxwZXIoKTtcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkNjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ2O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ3O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgfVxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCB7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSk7XG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9PUEVOKTtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ0KTtcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBFdmVudEhhbmRsZXIub2ZmKHdpbmRvdywgRVZFTlRfS0VZJDQpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZGlhbG9nLCBFVkVOVF9LRVkkNCk7XG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgIGlzVmlzaWJsZTogQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApLFxuICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlLFxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KTtcbiAgfVxuICBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgIC8vIHRyeSB0byBhcHBlbmQgZHluYW1pYyBtb2RhbFxuICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgY29uc3QgbW9kYWxCb2R5ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NT0RBTF9CT0RZLCB0aGlzLl9kaWFsb2cpO1xuICAgIGlmIChtb2RhbEJvZHkpIHtcbiAgICAgIG1vZGFsQm9keS5zY3JvbGxUb3AgPSAwO1xuICAgIH1cbiAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ0KTtcbiAgICBjb25zdCB0cmFuc2l0aW9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzdHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ0LCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayh0cmFuc2l0aW9uQ29tcGxldGUsIHRoaXMuX2RpYWxvZywgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgIH0pO1xuICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSQxLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNTaG93biAmJiAhdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgLy8gYSBiYWQgdHJpY2sgdG8gc2VncmVnYXRlIGNsaWNrcyB0aGF0IG1heSBzdGFydCBpbnNpZGUgZGlhbG9nIGJ1dCBlbmQgb3V0c2lkZSwgYW5kIGF2b2lkIGxpc3RlbiB0byBzY3JvbGxiYXIgY2xpY2tzXG4gICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MsIGV2ZW50MiA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgfHwgdGhpcy5fZWxlbWVudCAhPT0gZXZlbnQyLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGlkZU1vZGFsKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9PUEVOKTtcbiAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKTtcbiAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDQpO1xuICAgIH0pO1xuICB9XG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XG4gIH1cbiAgX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQkMSk7XG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBpbml0aWFsT3ZlcmZsb3dZID0gdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1k7XG4gICAgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXG4gICAgaWYgKGluaXRpYWxPdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU1RBVElDKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NUQVRJQyk7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBpbml0aWFsT3ZlcmZsb3dZO1xuICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcbiAgICB9LCB0aGlzLl9kaWFsb2cpO1xuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAgKi9cblxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGlzQm9keU92ZXJmbG93aW5nID0gc2Nyb2xsYmFyV2lkdGggPiAwO1xuICAgIGlmIChpc0JvZHlPdmVyZmxvd2luZyAmJiAhaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IGlzUlRMKCkgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICB9XG4gICAgaWYgKCFpc0JvZHlPdmVyZmxvd2luZyAmJiBpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNSVEwoKSA/ICdwYWRkaW5nUmlnaHQnIDogJ3BhZGRpbmdMZWZ0JztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xuICAgIH1cbiAgfVxuICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQyLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX1NIT1ckNCwgc2hvd0V2ZW50ID0+IHtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQ0LCAoKSA9PiB7XG4gICAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBtb2RhbCB0b2dnbGVyIHdoaWxlIGFub3RoZXIgb25lIGlzIG9wZW5cbiAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IkMSk7XG4gIGlmIChhbHJlYWR5T3Blbikge1xuICAgIE1vZGFsLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XG4gIH1cbiAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcbiAgZGF0YS50b2dnbGUodGhpcyk7XG59KTtcbmVuYWJsZURpc21pc3NUcmlnZ2VyKE1vZGFsKTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oTW9kYWwpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgb2ZmY2FudmFzLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkNiA9ICdvZmZjYW52YXMnO1xuY29uc3QgREFUQV9LRVkkMyA9ICdicy5vZmZjYW52YXMnO1xuY29uc3QgRVZFTlRfS0VZJDMgPSBgLiR7REFUQV9LRVkkM31gO1xuY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMiA9IGBsb2FkJHtFVkVOVF9LRVkkM30ke0RBVEFfQVBJX0tFWSQxfWA7XG5jb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMyA9ICdzaG93JztcbmNvbnN0IENMQVNTX05BTUVfU0hPV0lORyQxID0gJ3Nob3dpbmcnO1xuY29uc3QgQ0xBU1NfTkFNRV9ISURJTkcgPSAnaGlkaW5nJztcbmNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnb2ZmY2FudmFzLWJhY2tkcm9wJztcbmNvbnN0IE9QRU5fU0VMRUNUT1IgPSAnLm9mZmNhbnZhcy5zaG93JztcbmNvbnN0IEVWRU5UX1NIT1ckMyA9IGBzaG93JHtFVkVOVF9LRVkkM31gO1xuY29uc3QgRVZFTlRfU0hPV04kMyA9IGBzaG93biR7RVZFTlRfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX0hJREUkMyA9IGBoaWRlJHtFVkVOVF9LRVkkM31gO1xuY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQgPSBgaGlkZVByZXZlbnRlZCR7RVZFTlRfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX1JFU0laRSA9IGByZXNpemUke0VWRU5UX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQxID0gYGNsaWNrJHtFVkVOVF9LRVkkM30ke0RBVEFfQVBJX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkM31gO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMSA9ICdbZGF0YS1icy10b2dnbGU9XCJvZmZjYW52YXNcIl0nO1xuY29uc3QgRGVmYXVsdCQ1ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNjcm9sbDogZmFsc2Vcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ1ID0ge1xuICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBzY3JvbGw6ICdib29sZWFuJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgT2ZmY2FudmFzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XG4gICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ1O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDU7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDY7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICB9XG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMywge1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pO1xuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcbiAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XG4gICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkuaGlkZSgpO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkckMSk7XG4gICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCB8fCB0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDMpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyQxKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDMsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkMyk7XG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgdGhpcy5fZWxlbWVudC5ibHVyKCk7XG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJRElORyk7XG4gICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICAgIGNvbnN0IGNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMsIENMQVNTX05BTUVfSElESU5HKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XG4gICAgICAgIG5ldyBTY3JvbGxCYXJIZWxwZXIoKS5yZXNldCgpO1xuICAgICAgfVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDMpO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxiYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICBjb25zdCBjbGlja0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9O1xuXG4gICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXG4gICAgY29uc3QgaXNWaXNpYmxlID0gQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApO1xuICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xuICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FX0JBQ0tEUk9QLFxuICAgICAgaXNWaXNpYmxlLFxuICAgICAgaXNBbmltYXRlZDogdHJ1ZSxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBjbGlja0NhbGxiYWNrOiBpc1Zpc2libGUgPyBjbGlja0NhbGxiYWNrIDogbnVsbFxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcbiAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XG4gICAgfSk7XG4gIH1cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQzLCAoKSA9PiB7XG4gICAgLy8gZm9jdXMgb24gdHJpZ2dlciB3aGVuIGl0IGlzIGNsb3NlZFxuICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgYSB0b2dnbGVyIG9mIGFuIG9mZmNhbnZhcywgd2hpbGUgYW5vdGhlciBpcyBvcGVuXG4gIGNvbnN0IGFscmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKTtcbiAgaWYgKGFscmVhZHlPcGVuICYmIGFscmVhZHlPcGVuICE9PSB0YXJnZXQpIHtcbiAgICBPZmZjYW52YXMuZ2V0SW5zdGFuY2UoYWxyZWFkeU9wZW4pLmhpZGUoKTtcbiAgfVxuICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcbiAgZGF0YS50b2dnbGUodGhpcyk7XG59KTtcbkV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMiwgKCkgPT4ge1xuICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoT1BFTl9TRUxFQ1RPUikpIHtcbiAgICBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZShzZWxlY3Rvcikuc2hvdygpO1xuICB9XG59KTtcbkV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSwgKCkgPT4ge1xuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZCgnW2FyaWEtbW9kYWxdW2NsYXNzKj1zaG93XVtjbGFzcyo9b2ZmY2FudmFzLV0nKSkge1xuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KS5oaWRlKCk7XG4gICAgfVxuICB9XG59KTtcbmVuYWJsZURpc21pc3NUcmlnZ2VyKE9mZmNhbnZhcyk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKE9mZmNhbnZhcyk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL3Nhbml0aXplci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8vIGpzLWRvY3Mtc3RhcnQgYWxsb3ctbGlzdFxuY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xuY29uc3QgRGVmYXVsdEFsbG93bGlzdCA9IHtcbiAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkZDogW10sXG4gIGRpdjogW10sXG4gIGRsOiBbXSxcbiAgZHQ6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgbGk6IFtdLFxuICBvbDogW10sXG4gIHA6IFtdLFxuICBwcmU6IFtdLFxuICBzOiBbXSxcbiAgc21hbGw6IFtdLFxuICBzcGFuOiBbXSxcbiAgc3ViOiBbXSxcbiAgc3VwOiBbXSxcbiAgc3Ryb25nOiBbXSxcbiAgdTogW10sXG4gIHVsOiBbXVxufTtcbi8vIGpzLWRvY3MtZW5kIGFsbG93LWxpc3RcblxuY29uc3QgdXJpQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXSk7XG5cbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBVUkxzIHRoYXQgYXJlIHNhZmUgd3J0LiBYU1MgaW4gVVJMIG5hdmlnYXRpb25cbiAqIGNvbnRleHRzLlxuICpcbiAqIFNob3V0LW91dCB0byBBbmd1bGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xNS4yLjgvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHMjTDM4XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD8hamF2YXNjcmlwdDopKD86W2EtejAtOSsuLV0rOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvaTtcbmNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChhbGxvd2VkQXR0cmlidXRlTGlzdC5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgIGlmICh1cmlBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oU0FGRV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cbiAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKTtcbn07XG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZ1bmN0aW9uKSB7XG4gIGlmICghdW5zYWZlSHRtbC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5zYWZlSHRtbDtcbiAgfVxuICBpZiAoc2FuaXRpemVGdW5jdGlvbiAmJiB0eXBlb2Ygc2FuaXRpemVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzYW5pdGl6ZUZ1bmN0aW9uKHVuc2FmZUh0bWwpO1xuICB9XG4gIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpO1xuICBjb25zdCBlbGVtZW50cyA9IFtdLmNvbmNhdCguLi5jcmVhdGVkRG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICBjb25zdCBlbGVtZW50TmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGFsbG93TGlzdCkuaW5jbHVkZXMoZWxlbWVudE5hbWUpKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBbXS5jb25jYXQoLi4uZWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlcyA9IFtdLmNvbmNhdChhbGxvd0xpc3RbJyonXSB8fCBbXSwgYWxsb3dMaXN0W2VsZW1lbnROYW1lXSB8fCBbXSk7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlTGlzdCkge1xuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUw7XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL3RlbXBsYXRlLWZhY3RvcnkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQ1ID0gJ1RlbXBsYXRlRmFjdG9yeSc7XG5jb25zdCBEZWZhdWx0JDQgPSB7XG4gIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgY29udGVudDoge30sXG4gIC8vIHsgc2VsZWN0b3IgOiB0ZXh0ICwgIHNlbGVjdG9yMiA6IHRleHQyICwgfVxuICBleHRyYUNsYXNzOiAnJyxcbiAgaHRtbDogZmFsc2UsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+J1xufTtcbmNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XG4gIGFsbG93TGlzdDogJ29iamVjdCcsXG4gIGNvbnRlbnQ6ICdvYmplY3QnLFxuICBleHRyYUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBodG1sOiAnYm9vbGVhbicsXG4gIHNhbml0aXplOiAnYm9vbGVhbicsXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICB0ZW1wbGF0ZTogJ3N0cmluZydcbn07XG5jb25zdCBEZWZhdWx0Q29udGVudFR5cGUgPSB7XG4gIGVudHJ5OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9ufG51bGwpJyxcbiAgc2VsZWN0b3I6ICcoc3RyaW5nfGVsZW1lbnQpJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgVGVtcGxhdGVGYWN0b3J5IGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDQ7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkNDtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkNTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KS5tYXAoY29uZmlnID0+IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbmZpZykpLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBoYXNDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRlbnQoKS5sZW5ndGggPiAwO1xuICB9XG4gIGNoYW5nZUNvbnRlbnQoY29udGVudCkge1xuICAgIHRoaXMuX2NoZWNrQ29udGVudChjb250ZW50KTtcbiAgICB0aGlzLl9jb25maWcuY29udGVudCA9IHtcbiAgICAgIC4uLnRoaXMuX2NvbmZpZy5jb250ZW50LFxuICAgICAgLi4uY29udGVudFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9IdG1sKCkge1xuICAgIGNvbnN0IHRlbXBsYXRlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRlbXBsYXRlV3JhcHBlci5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKHRoaXMuX2NvbmZpZy50ZW1wbGF0ZSk7XG4gICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xuICAgICAgdGhpcy5fc2V0Q29udGVudCh0ZW1wbGF0ZVdyYXBwZXIsIHRleHQsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVdyYXBwZXIuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgZXh0cmFDbGFzcyA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5leHRyYUNsYXNzKTtcbiAgICBpZiAoZXh0cmFDbGFzcykge1xuICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCguLi5leHRyYUNsYXNzLnNwbGl0KCcgJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF90eXBlQ2hlY2tDb25maWcoY29uZmlnKSB7XG4gICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2NoZWNrQ29udGVudChjb25maWcuY29udGVudCk7XG4gIH1cbiAgX2NoZWNrQ29udGVudChhcmcpIHtcbiAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoYXJnKSkge1xuICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyh7XG4gICAgICAgIHNlbGVjdG9yLFxuICAgICAgICBlbnRyeTogY29udGVudFxuICAgICAgfSwgRGVmYXVsdENvbnRlbnRUeXBlKTtcbiAgICB9XG4gIH1cbiAgX3NldENvbnRlbnQodGVtcGxhdGUsIGNvbnRlbnQsIHNlbGVjdG9yKSB7XG4gICAgY29uc3QgdGVtcGxhdGVFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvciwgdGVtcGxhdGUpO1xuICAgIGlmICghdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRlbnQgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb250ZW50KTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIHRlbXBsYXRlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChjb250ZW50KSkge1xuICAgICAgdGhpcy5fcHV0RWxlbWVudEluVGVtcGxhdGUoZ2V0RWxlbWVudChjb250ZW50KSwgdGVtcGxhdGVFbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZShjb250ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcbiAgfVxuICBfbWF5YmVTYW5pdGl6ZShhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnNhbml0aXplID8gc2FuaXRpemVIdG1sKGFyZywgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pIDogYXJnO1xuICB9XG4gIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZXhlY3V0ZShhcmcsIFt1bmRlZmluZWQsIHRoaXNdKTtcbiAgfVxuICBfcHV0RWxlbWVudEluVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB0b29sdGlwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkNCA9ICd0b29sdGlwJztcbmNvbnN0IERJU0FMTE9XRURfQVRUUklCVVRFUyA9IG5ldyBTZXQoWydzYW5pdGl6ZScsICdhbGxvd0xpc3QnLCAnc2FuaXRpemVGbiddKTtcbmNvbnN0IENMQVNTX05BTUVfRkFERSQyID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9NT0RBTCA9ICdtb2RhbCc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMiA9ICdzaG93JztcbmNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInO1xuY29uc3QgU0VMRUNUT1JfTU9EQUwgPSBgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gO1xuY29uc3QgRVZFTlRfTU9EQUxfSElERSA9ICdoaWRlLmJzLm1vZGFsJztcbmNvbnN0IFRSSUdHRVJfSE9WRVIgPSAnaG92ZXInO1xuY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XG5jb25zdCBUUklHR0VSX0NMSUNLID0gJ2NsaWNrJztcbmNvbnN0IFRSSUdHRVJfTUFOVUFMID0gJ21hbnVhbCc7XG5jb25zdCBFVkVOVF9ISURFJDIgPSAnaGlkZSc7XG5jb25zdCBFVkVOVF9ISURERU4kMiA9ICdoaWRkZW4nO1xuY29uc3QgRVZFTlRfU0hPVyQyID0gJ3Nob3cnO1xuY29uc3QgRVZFTlRfU0hPV04kMiA9ICdzaG93bic7XG5jb25zdCBFVkVOVF9JTlNFUlRFRCA9ICdpbnNlcnRlZCc7XG5jb25zdCBFVkVOVF9DTElDSyQxID0gJ2NsaWNrJztcbmNvbnN0IEVWRU5UX0ZPQ1VTSU4kMSA9ICdmb2N1c2luJztcbmNvbnN0IEVWRU5UX0ZPQ1VTT1VUJDEgPSAnZm9jdXNvdXQnO1xuY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJztcbmNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSc7XG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xuICBBVVRPOiAnYXV0bycsXG4gIFRPUDogJ3RvcCcsXG4gIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgQk9UVE9NOiAnYm90dG9tJyxcbiAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcbn07XG5jb25zdCBEZWZhdWx0JDMgPSB7XG4gIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gIGNvbnRhaW5lcjogZmFsc2UsXG4gIGN1c3RvbUNsYXNzOiAnJyxcbiAgZGVsYXk6IDAsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgaHRtbDogZmFsc2UsXG4gIG9mZnNldDogWzAsIDZdLFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICBzZWxlY3RvcjogZmFsc2UsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxuICB0aXRsZTogJycsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cydcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQzID0ge1xuICBhbGxvd0xpc3Q6ICdvYmplY3QnLFxuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgY29udGFpbmVyOiAnKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pJyxcbiAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiAnYXJyYXknLFxuICBodG1sOiAnYm9vbGVhbicsXG4gIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcbiAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXG4gIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXG4gIHRlbXBsYXRlOiAnc3RyaW5nJyxcbiAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgdHJpZ2dlcjogJ3N0cmluZydcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi8pJyk7XG4gICAgfVxuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgICB0aGlzLl9pc0hvdmVyZWQgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG51bGw7XG4gICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7XG5cbiAgICAvLyBQcm90ZWN0ZWRcbiAgICB0aGlzLnRpcCA9IG51bGw7XG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkMztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQzO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ0O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgdG9nZ2xlRW5hYmxlZCgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICB0aGlzLl9sZWF2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbnRlcigpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpO1xuICAgIH1cbiAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XG4gICAgfVxuICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1ckMikpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBmaW5kU2hhZG93Um9vdCh0aGlzLl9lbGVtZW50KTtcbiAgICBjb25zdCBpc0luVGhlRG9tID0gKHNoYWRvd1Jvb3QgfHwgdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuY29udGFpbnModGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdjYgcmVtb3ZlIHRoaXMgb3IgbWFrZSBpdCBvcHRpb25hbFxuICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcbiAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUaXBFbGVtZW50KCk7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXAuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXJcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLnRpcCkpIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmQodGlwKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0lOU0VSVEVEKSk7XG4gICAgfVxuICAgIHRoaXMuX3BvcHBlciA9IHRoaXMuX2NyZWF0ZVBvcHBlcih0aXApO1xuICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQyKTtcblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1dOJDIpKTtcbiAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2xlYXZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElERSQyKSk7XG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcbiAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMik7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9GT0NVU10gPSBmYWxzZTtcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfSE9WRVJdID0gZmFsc2U7XG4gICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDsgLy8gaXQgaXMgYSB0cmljayB0byBzdXBwb3J0IG1hbnVhbCB0cmlnZ2VyaW5nXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJRERFTiQyKSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByb3RlY3RlZFxuICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXRUaXRsZSgpKTtcbiAgfVxuICBfZ2V0VGlwRWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMudGlwKSB7XG4gICAgICB0aGlzLnRpcCA9IHRoaXMuX2NyZWF0ZVRpcEVsZW1lbnQodGhpcy5fbmV3Q29udGVudCB8fCB0aGlzLl9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpcDtcbiAgfVxuICBfY3JlYXRlVGlwRWxlbWVudChjb250ZW50KSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpLnRvSHRtbCgpO1xuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgaW4gdjZcbiAgICBpZiAoIXRpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfRkFERSQyLCBDTEFTU19OQU1FX1NIT1ckMik7XG4gICAgLy8gVE9ETzogdjYgdGhlIGZvbGxvd2luZyBjYW4gYmUgYWNoaWV2ZWQgd2l0aCBDU1Mgb25seVxuICAgIHRpcC5jbGFzc0xpc3QuYWRkKGBicy0ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXV0b2ApO1xuICAgIGNvbnN0IHRpcElkID0gZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSkudG9TdHJpbmcoKTtcbiAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcbiAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkMik7XG4gICAgfVxuICAgIHJldHVybiB0aXA7XG4gIH1cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5fbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG4gIF9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkge1xuICAgIGlmICh0aGlzLl90ZW1wbGF0ZUZhY3RvcnkpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeS5jaGFuZ2VDb250ZW50KGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBuZXcgVGVtcGxhdGVGYWN0b3J5KHtcbiAgICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgICAvLyB0aGUgYGNvbnRlbnRgIHZhciBoYXMgdG8gYmUgYWZ0ZXIgYHRoaXMuX2NvbmZpZ2BcbiAgICAgICAgLy8gdG8gb3ZlcnJpZGUgY29uZmlnLmNvbnRlbnQgaW4gY2FzZSBvZiBwb3BvdmVyXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGV4dHJhQ2xhc3M6IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVGYWN0b3J5O1xuICB9XG4gIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTRUxFQ1RPUl9UT09MVElQX0lOTkVSXTogdGhpcy5fZ2V0VGl0bGUoKVxuICAgIH07XG4gIH1cbiAgX2dldFRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcudGl0bGUpIHx8IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJyk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgfVxuICBfaXNBbmltYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmFuaW1hdGlvbiB8fCB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICB9XG4gIF9pc1Nob3duKCkge1xuICAgIHJldHVybiB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuICB9XG4gIF9jcmVhdGVQb3BwZXIodGlwKSB7XG4gICAgY29uc3QgcGxhY2VtZW50ID0gZXhlY3V0ZSh0aGlzLl9jb25maWcucGxhY2VtZW50LCBbdGhpcywgdGlwLCB0aGlzLl9lbGVtZW50XSk7XG4gICAgY29uc3QgYXR0YWNobWVudCA9IEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xuICAgIHJldHVybiBQb3BwZXIuY3JlYXRlUG9wcGVyKHRoaXMuX2VsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKTtcbiAgfVxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFxuICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGUoYXJnLCBbdGhpcy5fZWxlbWVudCwgdGhpcy5fZWxlbWVudF0pO1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xuICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudDogYXR0YWNobWVudCxcbiAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdwcmVTZXRQbGFjZW1lbnQnLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwaGFzZTogJ2JlZm9yZU1haW4nLFxuICAgICAgICBmbjogZGF0YSA9PiB7XG4gICAgICAgICAgLy8gUHJlLXNldCBQb3BwZXIncyBwbGFjZW1lbnQgYXR0cmlidXRlIGluIG9yZGVyIHRvIHJlYWQgdGhlIGFycm93IHNpemVzIHByb3Blcmx5LlxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgUG9wcGVyIG1peGVzIHVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMgc2luY2UgdGhlIGluaXRpYWwgYXJyb3cgc3R5bGUgaXMgZm9yIHRvcCBwbGFjZW1lbnRcbiAgICAgICAgICB0aGlzLl9nZXRUaXBFbGVtZW50KCkuc2V0QXR0cmlidXRlKCdkYXRhLXBvcHBlci1wbGFjZW1lbnQnLCBkYXRhLnN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxuICAgICAgLi4uZXhlY3V0ZSh0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnLCBbdW5kZWZpbmVkLCBkZWZhdWx0QnNQb3BwZXJDb25maWddKVxuICAgIH07XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRyaWdnZXJzKSB7XG4gICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgIGNvbnRleHQudG9nZ2xlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFRU5URVIpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNJTiQxKTtcbiAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VMRUFWRSkgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU09VVCQxKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50SW4sIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcbiAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSBjb250ZXh0Ll9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgIGNvbnRleHQuX2xlYXZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG4gIH1cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgJiYgIXRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSk7IC8vIERPIE5PVCBVU0UgSVQuIElzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gIH1cbiAgX2VudGVyKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKCkgfHwgdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuc2hvdyk7XG4gIH1cbiAgX2xlYXZlKCkge1xuICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNIb3ZlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuaGlkZSk7XG4gIH1cbiAgX3NldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KTtcbiAgfVxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9hY3RpdmVUcmlnZ2VyKS5pbmNsdWRlcyh0cnVlKTtcbiAgfVxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBkYXRhQXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyaWJ1dGVdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5kYXRhQXR0cmlidXRlcyxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICB9O1xuICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XG4gICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XG4gICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcbiAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCBjb25maWcgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLl9jb25maWcpKSB7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbmZpZy5zZWxlY3RvciA9IGZhbHNlO1xuICAgIGNvbmZpZy50cmlnZ2VyID0gJ21hbnVhbCc7XG5cbiAgICAvLyBJbiB0aGUgZnV0dXJlIGNhbiBiZSByZXBsYWNlZCB3aXRoOlxuICAgIC8vIGNvbnN0IGtleXNXaXRoRGlmZmVyZW50VmFsdWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKS5maWx0ZXIoZW50cnkgPT4gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VudHJ5WzBdXSAhPT0gdGhpcy5fY29uZmlnW2VudHJ5WzBdXSlcbiAgICAvLyBgT2JqZWN0LmZyb21FbnRyaWVzKGtleXNXaXRoRGlmZmVyZW50VmFsdWVzKWBcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9kaXNwb3NlUG9wcGVyKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy50aXApIHtcbiAgICAgIHRoaXMudGlwLnJlbW92ZSgpO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRvb2x0aXAuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oVG9vbHRpcCk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBwb3BvdmVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkMyA9ICdwb3BvdmVyJztcbmNvbnN0IFNFTEVDVE9SX1RJVExFID0gJy5wb3BvdmVyLWhlYWRlcic7XG5jb25zdCBTRUxFQ1RPUl9DT05URU5UID0gJy5wb3BvdmVyLWJvZHknO1xuY29uc3QgRGVmYXVsdCQyID0ge1xuICAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gIGNvbnRlbnQ6ICcnLFxuICBvZmZzZXQ6IFswLCA4XSxcbiAgcGxhY2VtZW50OiAncmlnaHQnLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWFycm93XCI+PC9kaXY+JyArICc8aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+JyArICc8L2Rpdj4nLFxuICB0cmlnZ2VyOiAnY2xpY2snXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkMiA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcbiAgY29udGVudDogJyhudWxsfHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKSdcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkMjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQzO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGVzXG4gIF9pc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1NFTEVDVE9SX1RJVExFXTogdGhpcy5fZ2V0VGl0bGUoKSxcbiAgICAgIFtTRUxFQ1RPUl9DT05URU5UXTogdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgfTtcbiAgfVxuICBfZ2V0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmNvbnRlbnQpO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gUG9wb3Zlci5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG4gICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihQb3BvdmVyKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHNjcm9sbHNweS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDIgPSAnc2Nyb2xsc3B5JztcbmNvbnN0IERBVEFfS0VZJDIgPSAnYnMuc2Nyb2xsc3B5JztcbmNvbnN0IEVWRU5UX0tFWSQyID0gYC4ke0RBVEFfS0VZJDJ9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuY29uc3QgRVZFTlRfQUNUSVZBVEUgPSBgYWN0aXZhdGUke0VWRU5UX0tFWSQyfWA7XG5jb25zdCBFVkVOVF9DTElDSyA9IGBjbGljayR7RVZFTlRfS0VZJDJ9YDtcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMSA9IGBsb2FkJHtFVkVOVF9LRVkkMn0ke0RBVEFfQVBJX0tFWX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNID0gJ2Ryb3Bkb3duLWl0ZW0nO1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMSA9ICdhY3RpdmUnO1xuY29uc3QgU0VMRUNUT1JfREFUQV9TUFkgPSAnW2RhdGEtYnMtc3B5PVwic2Nyb2xsXCJdJztcbmNvbnN0IFNFTEVDVE9SX1RBUkdFVF9MSU5LUyA9ICdbaHJlZl0nO1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJTktTID0gJy5uYXYtbGluayc7XG5jb25zdCBTRUxFQ1RPUl9OQVZfSVRFTVMgPSAnLm5hdi1pdGVtJztcbmNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSc7XG5jb25zdCBTRUxFQ1RPUl9MSU5LX0lURU1TID0gYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9OQVZfSVRFTVN9ID4gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX0xJU1RfSVRFTVN9YDtcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOID0gJy5kcm9wZG93bic7XG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcbmNvbnN0IERlZmF1bHQkMSA9IHtcbiAgb2Zmc2V0OiBudWxsLFxuICAvLyBUT0RPOiB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xuICByb290TWFyZ2luOiAnMHB4IDBweCAtMjUlJyxcbiAgc21vb3RoU2Nyb2xsOiBmYWxzZSxcbiAgdGFyZ2V0OiBudWxsLFxuICB0aHJlc2hvbGQ6IFswLjEsIDAuNSwgMV1cbn07XG5jb25zdCBEZWZhdWx0VHlwZSQxID0ge1xuICBvZmZzZXQ6ICcobnVtYmVyfG51bGwpJyxcbiAgLy8gVE9ETyB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xuICByb290TWFyZ2luOiAnc3RyaW5nJyxcbiAgc21vb3RoU2Nyb2xsOiAnYm9vbGVhbicsXG4gIHRhcmdldDogJ2VsZW1lbnQnLFxuICB0aHJlc2hvbGQ6ICdhcnJheSdcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFNjcm9sbFNweSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuXG4gICAgLy8gdGhpcy5fZWxlbWVudCBpcyB0aGUgb2JzZXJ2YWJsZXNDb250YWluZXIgYW5kIGNvbmZpZy50YXJnZXQgdGhlIG1lbnUgbGlua3Mgd3JhcHBlclxuICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yb290RWxlbWVudCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkub3ZlcmZsb3dZID09PSAndmlzaWJsZScgPyBudWxsIDogdGhpcy5fZWxlbWVudDtcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEgPSB7XG4gICAgICB2aXNpYmxlRW50cnlUb3A6IDAsXG4gICAgICBwYXJlbnRTY3JvbGxUb3A6IDBcbiAgICB9O1xuICAgIHRoaXMucmVmcmVzaCgpOyAvLyBpbml0aWFsaXplXG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQxO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDI7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKCk7XG4gICAgdGhpcy5fbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKTtcbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9nZXROZXdPYnNlcnZlcigpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHNlY3Rpb24pO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgIC8vIFRPRE86IG9uIHY2IHRhcmdldCBzaG91bGQgYmUgZ2l2ZW4gZXhwbGljaXRseSAmIHJlbW92ZSB0aGUge3RhcmdldDogJ3NzLXRhcmdldCd9IGNhc2VcbiAgICBjb25maWcudGFyZ2V0ID0gZ2V0RWxlbWVudChjb25maWcudGFyZ2V0KSB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgLy8gVE9ETzogdjYgT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gVXNlIHJvb3RNYXJnaW4gb25seVxuICAgIGNvbmZpZy5yb290TWFyZ2luID0gY29uZmlnLm9mZnNldCA/IGAke2NvbmZpZy5vZmZzZXR9cHggMHB4IC0zMCVgIDogY29uZmlnLnJvb3RNYXJnaW47XG4gICAgaWYgKHR5cGVvZiBjb25maWcudGhyZXNob2xkID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnLnRocmVzaG9sZCA9IGNvbmZpZy50aHJlc2hvbGQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuc21vb3RoU2Nyb2xsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdW5yZWdpc3RlciBhbnkgcHJldmlvdXMgbGlzdGVuZXJzXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSyk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLLCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLmdldChldmVudC50YXJnZXQuaGFzaCk7XG4gICAgICBpZiAob2JzZXJ2YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3RFbGVtZW50IHx8IHdpbmRvdztcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gb2JzZXJ2YWJsZVNlY3Rpb24ub2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICAgIGlmIChyb290LnNjcm9sbFRvKSB7XG4gICAgICAgICAgcm9vdC5zY3JvbGxUbyh7XG4gICAgICAgICAgICB0b3A6IGhlaWdodCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENocm9tZSA2MCBkb2Vzbid0IHN1cHBvcnQgYHNjcm9sbFRvYFxuICAgICAgICByb290LnNjcm9sbFRvcCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZ2V0TmV3T2JzZXJ2ZXIoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3Q6IHRoaXMuX3Jvb3RFbGVtZW50LFxuICAgICAgdGhyZXNob2xkOiB0aGlzLl9jb25maWcudGhyZXNob2xkLFxuICAgICAgcm9vdE1hcmdpbjogdGhpcy5fY29uZmlnLnJvb3RNYXJnaW5cbiAgICB9O1xuICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB0aGlzLl9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFRoZSBsb2dpYyBvZiBzZWxlY3Rpb25cbiAgX29ic2VydmVyQ2FsbGJhY2soZW50cmllcykge1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBlbnRyeSA9PiB0aGlzLl90YXJnZXRMaW5rcy5nZXQoYCMke2VudHJ5LnRhcmdldC5pZH1gKTtcbiAgICBjb25zdCBhY3RpdmF0ZSA9IGVudHJ5ID0+IHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3AgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wO1xuICAgICAgdGhpcy5fcHJvY2Vzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XG4gICAgfTtcbiAgICBjb25zdCBwYXJlbnRTY3JvbGxUb3AgPSAodGhpcy5fcm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5zY3JvbGxUb3A7XG4gICAgY29uc3QgdXNlclNjcm9sbHNEb3duID0gcGFyZW50U2Nyb2xsVG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3A7XG4gICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcCA9IHBhcmVudFNjcm9sbFRvcDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIGlmICghZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2xlYXJBY3RpdmVDbGFzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZW50cnlJc0xvd2VyVGhhblByZXZpb3VzID0gZW50cnkudGFyZ2V0Lm9mZnNldFRvcCA+PSB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEudmlzaWJsZUVudHJ5VG9wO1xuICAgICAgLy8gaWYgd2UgYXJlIHNjcm9sbGluZyBkb3duLCBwaWNrIHRoZSBiaWdnZXIgb2Zmc2V0VG9wXG4gICAgICBpZiAodXNlclNjcm9sbHNEb3duICYmIGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xuICAgICAgICBhY3RpdmF0ZShlbnRyeSk7XG4gICAgICAgIC8vIGlmIHBhcmVudCBpc24ndCBzY3JvbGxlZCwgbGV0J3Mga2VlcCB0aGUgZmlyc3QgdmlzaWJsZSBpdGVtLCBicmVha2luZyB0aGUgaXRlcmF0aW9uXG4gICAgICAgIGlmICghcGFyZW50U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBhcmUgc2Nyb2xsaW5nIHVwLCBwaWNrIHRoZSBzbWFsbGVzdCBvZmZzZXRUb3BcbiAgICAgIGlmICghdXNlclNjcm9sbHNEb3duICYmICFlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcbiAgICAgICAgYWN0aXZhdGUoZW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpIHtcbiAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdGFyZ2V0TGlua3MgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1RBUkdFVF9MSU5LUywgdGhpcy5fY29uZmlnLnRhcmdldCk7XG4gICAgZm9yIChjb25zdCBhbmNob3Igb2YgdGFyZ2V0TGlua3MpIHtcbiAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBhbmNob3IgaGFzIGFuIGlkIGFuZCBpcyBub3QgZGlzYWJsZWRcbiAgICAgIGlmICghYW5jaG9yLmhhc2ggfHwgaXNEaXNhYmxlZChhbmNob3IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2JzZXJ2YWJsZVNlY3Rpb24gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKGRlY29kZVVSSShhbmNob3IuaGFzaCksIHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgb2JzZXJ2YWJsZVNlY3Rpb24gZXhpc3RzICYgaXMgdmlzaWJsZVxuICAgICAgaWYgKGlzVmlzaWJsZShvYnNlcnZhYmxlU2VjdGlvbikpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0TGlua3Muc2V0KGRlY29kZVVSSShhbmNob3IuaGFzaCksIGFuY2hvcik7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5zZXQoYW5jaG9yLmhhc2gsIG9ic2VydmFibGVTZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Byb2Nlc3ModGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGhpcy5fY29uZmlnLnRhcmdldCk7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgIHRoaXMuX2FjdGl2YXRlUGFyZW50cyh0YXJnZXQpO1xuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0FDVElWQVRFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcbiAgICB9KTtcbiAgfVxuICBfYWN0aXZhdGVQYXJlbnRzKHRhcmdldCkge1xuICAgIC8vIEFjdGl2YXRlIGRyb3Bkb3duIHBhcmVudHNcbiAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0lURU0pKSB7XG4gICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGlzdEdyb3VwIG9mIFNlbGVjdG9yRW5naW5lLnBhcmVudHModGFyZ2V0LCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCkpIHtcbiAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcbiAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFNlbGVjdG9yRW5naW5lLnByZXYobGlzdEdyb3VwLCBTRUxFQ1RPUl9MSU5LX0lURU1TKSkge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jbGVhckFjdGl2ZUNsYXNzKHBhcmVudCkge1xuICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgIGNvbnN0IGFjdGl2ZU5vZGVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChgJHtTRUxFQ1RPUl9UQVJHRVRfTElOS1N9LiR7Q0xBU1NfTkFNRV9BQ1RJVkUkMX1gLCBwYXJlbnQpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhY3RpdmVOb2Rlcykge1xuICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG4gICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQxLCAoKSA9PiB7XG4gIGZvciAoY29uc3Qgc3B5IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9TUFkpKSB7XG4gICAgU2Nyb2xsU3B5LmdldE9yQ3JlYXRlSW5zdGFuY2Uoc3B5KTtcbiAgfVxufSk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFNjcm9sbFNweSk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB0YWIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQxID0gJ3RhYic7XG5jb25zdCBEQVRBX0tFWSQxID0gJ2JzLnRhYic7XG5jb25zdCBFVkVOVF9LRVkkMSA9IGAuJHtEQVRBX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9ISURFJDEgPSBgaGlkZSR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX1NIT1ckMSA9IGBzaG93JHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfU0hPV04kMSA9IGBzaG93biR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgQVJST1dfTEVGVF9LRVkgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUX0tFWSA9ICdBcnJvd1JpZ2h0JztcbmNvbnN0IEFSUk9XX1VQX0tFWSA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XG5jb25zdCBIT01FX0tFWSA9ICdIb21lJztcbmNvbnN0IEVORF9LRVkgPSAnRW5kJztcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMSA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQxID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfRFJPUERPV04gPSAnZHJvcGRvd24nO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XG5jb25zdCBOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gYDpub3QoJHtTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9KWA7XG5jb25zdCBTRUxFQ1RPUl9UQUJfUEFORUwgPSAnLmxpc3QtZ3JvdXAsIC5uYXYsIFtyb2xlPVwidGFibGlzdFwiXSc7XG5jb25zdCBTRUxFQ1RPUl9PVVRFUiA9ICcubmF2LWl0ZW0sIC5saXN0LWdyb3VwLWl0ZW0nO1xuY29uc3QgU0VMRUNUT1JfSU5ORVIgPSBgLm5hdi1saW5rJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgLmxpc3QtZ3JvdXAtaXRlbSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIFtyb2xlPVwidGFiXCJdJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfWA7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl0nOyAvLyBUT0RPOiBjb3VsZCBvbmx5IGJlIGB0YWJgIGluIHY2XG5jb25zdCBTRUxFQ1RPUl9JTk5FUl9FTEVNID0gYCR7U0VMRUNUT1JfSU5ORVJ9LCAke1NFTEVDVE9SX0RBVEFfVE9HR0xFfWA7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdYDtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgVGFiIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfVEFCX1BBTkVMKTtcbiAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRocm93IGV4Y2VwdGlvbiBpbiB2NlxuICAgICAgLy8gdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtlbGVtZW50Lm91dGVySFRNTH0gaGFzIG5vdCBhIHZhbGlkIHBhcmVudCAke1NFTEVDVE9SX0lOTkVSX0VMRU19YClcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgaW5pdGlhbCBhcmlhIGF0dHJpYnV0ZXNcbiAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlcyh0aGlzLl9wYXJlbnQsIHRoaXMuX2dldENoaWxkcmVuKCkpO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQxO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHNob3coKSB7XG4gICAgLy8gU2hvd3MgdGhpcyBlbGVtIGFuZCBkZWFjdGl2YXRlIHRoZSBhY3RpdmUgc2libGluZyBpZiBleGlzdHNcbiAgICBjb25zdCBpbm5lckVsZW0gPSB0aGlzLl9lbGVtZW50O1xuICAgIGlmICh0aGlzLl9lbGVtSXNBY3RpdmUoaW5uZXJFbGVtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgYWN0aXZlIHRhYiBvbiBzYW1lIHBhcmVudCB0byBkZWFjdGl2YXRlIGl0XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbSgpO1xuICAgIGNvbnN0IGhpZGVFdmVudCA9IGFjdGl2ZSA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKGFjdGl2ZSwgRVZFTlRfSElERSQxLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBpbm5lckVsZW1cbiAgICB9KSA6IG51bGw7XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIoaW5uZXJFbGVtLCBFVkVOVF9TSE9XJDEsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IGFjdGl2ZVxuICAgIH0pO1xuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGVhY3RpdmF0ZShhY3RpdmUsIGlubmVyRWxlbSk7XG4gICAgdGhpcy5fYWN0aXZhdGUoaW5uZXJFbGVtLCBhY3RpdmUpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB0aGlzLl9hY3RpdmF0ZShTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBhY3RpdmF0ZS9zaG93IHRoZSBwcm9wZXIgc2VjdGlvblxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xuICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgdHJ1ZSk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9TSE9XTiQxLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRFbGVtXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XG4gIH1cbiAgX2RlYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICBlbGVtZW50LmJsdXIoKTtcbiAgICB0aGlzLl9kZWFjdGl2YXRlKFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGRlYWN0aXZhdGUgdGhlIHNob3duIHNlY3Rpb24gdG9vXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpICE9PSAndGFiJykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgZmFsc2UpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfSElEREVOJDEsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKTtcbiAgfVxuICBfa2V5ZG93bihldmVudCkge1xuICAgIGlmICghW0FSUk9XX0xFRlRfS0VZLCBBUlJPV19SSUdIVF9LRVksIEFSUk9XX1VQX0tFWSwgQVJST1dfRE9XTl9LRVksIEhPTUVfS0VZLCBFTkRfS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wUHJvcGFnYXRpb24vcHJldmVudERlZmF1bHQgYm90aCBhZGRlZCB0byBzdXBwb3J0IHVwL2Rvd24ga2V5cyB3aXRob3V0IHNjcm9sbGluZyB0aGUgcGFnZVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKTtcbiAgICBsZXQgbmV4dEFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKFtIT01FX0tFWSwgRU5EX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQgPSBjaGlsZHJlbltldmVudC5rZXkgPT09IEhPTUVfS0VZID8gMCA6IGNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc05leHQgPSBbQVJST1dfUklHSFRfS0VZLCBBUlJPV19ET1dOX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcbiAgICAgIG5leHRBY3RpdmVFbGVtZW50ID0gZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoY2hpbGRyZW4sIGV2ZW50LnRhcmdldCwgaXNOZXh0LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKG5leHRBY3RpdmVFbGVtZW50KSB7XG4gICAgICBuZXh0QWN0aXZlRWxlbWVudC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UobmV4dEFjdGl2ZUVsZW1lbnQpLnNob3coKTtcbiAgICB9XG4gIH1cbiAgX2dldENoaWxkcmVuKCkge1xuICAgIC8vIGNvbGxlY3Rpb24gb2YgaW5uZXIgZWxlbWVudHNcbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JTk5FUl9FTEVNLCB0aGlzLl9wYXJlbnQpO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbmQoY2hpbGQgPT4gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKSkgfHwgbnVsbDtcbiAgfVxuICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXMocGFyZW50LCBjaGlsZHJlbikge1xuICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHBhcmVudCwgJ3JvbGUnLCAndGFibGlzdCcpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIF9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpIHtcbiAgICBjaGlsZCA9IHRoaXMuX2dldElubmVyRWxlbWVudChjaGlsZCk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpO1xuICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChjaGlsZCk7XG4gICAgY2hpbGQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgaXNBY3RpdmUpO1xuICAgIGlmIChvdXRlckVsZW0gIT09IGNoaWxkKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhvdXRlckVsZW0sICdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuICAgIH1cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgfVxuICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKGNoaWxkLCAncm9sZScsICd0YWInKTtcblxuICAgIC8vIHNldCBhdHRyaWJ1dGVzIHRvIHRoZSByZWxhdGVkIHBhbmVsIHRvb1xuICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzT25UYXJnZXRQYW5lbChjaGlsZCk7XG4gIH1cbiAgX3NldEluaXRpYWxBdHRyaWJ1dGVzT25UYXJnZXRQYW5lbChjaGlsZCkge1xuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoY2hpbGQpO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ3JvbGUnLCAndGFicGFuZWwnKTtcbiAgICBpZiAoY2hpbGQuaWQpIHtcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ2FyaWEtbGFiZWxsZWRieScsIGAke2NoaWxkLmlkfWApO1xuICAgIH1cbiAgfVxuICBfdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgb3Blbikge1xuICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChlbGVtZW50KTtcbiAgICBpZiAoIW91dGVyRWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfRFJPUERPV04pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRvZ2dsZSA9IChzZWxlY3RvciwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3Rvciwgb3V0ZXJFbGVtKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIG9wZW4pO1xuICAgICAgfVxuICAgIH07XG4gICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VLCBDTEFTU19OQU1FX1NIT1ckMSk7XG4gICAgb3V0ZXJFbGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIG9wZW4pO1xuICB9XG4gIF9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgX2VsZW1Jc0FjdGl2ZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgdGhlIGlubmVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtbGluaylcbiAgX2dldElubmVyRWxlbWVudChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhTRUxFQ1RPUl9JTk5FUl9FTEVNKSA/IGVsZW0gOiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lOTkVSX0VMRU0sIGVsZW0pO1xuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB0aGUgb3V0ZXIgZWxlbWVudCAodXN1YWxseSB0aGUgLm5hdi1pdGVtKVxuICBfZ2V0T3V0ZXJFbGVtZW50KGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5jbG9zZXN0KFNFTEVDVE9SX09VVEVSKSB8fCBlbGVtO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG4gICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS5zaG93KCk7XG59KTtcblxuLyoqXG4gKiBJbml0aWFsaXplIG9uIGZvY3VzXG4gKi9cbkV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFKSkge1xuICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQpO1xuICB9XG59KTtcbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRhYik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB0b2FzdC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ3RvYXN0JztcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gO1xuY29uc3QgRVZFTlRfTU9VU0VPVkVSID0gYG1vdXNlb3ZlciR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9NT1VTRU9VVCA9IGBtb3VzZW91dCR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfRk9DVVNPVVQgPSBgZm9jdXNvdXQke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YDtcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfSElERSA9ICdoaWRlJzsgLy8gQGRlcHJlY2F0ZWQgLSBrZXB0IGhlcmUgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93JztcbmNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgYXV0b2hpZGU6ICdib29sZWFuJyxcbiAgZGVsYXk6ICdudW1iZXInXG59O1xuY29uc3QgRGVmYXVsdCA9IHtcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBhdXRvaGlkZTogdHJ1ZSxcbiAgZGVsYXk6IDUwMDBcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRvYXN0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpO1xuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTik7XG4gICAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfSElERSk7IC8vIEBkZXByZWNhdGVkXG4gICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1csIENMQVNTX05BTUVfU0hPV0lORyk7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTaG93bigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpO1xuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORywgQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTik7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgIGlmICh0aGlzLmlzU2hvd24oKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBpc1Nob3duKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gfHwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xuICB9XG4gIF9vbkludGVyYWN0aW9uKGV2ZW50LCBpc0ludGVyYWN0aW5nKSB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3Rpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3Rpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW50ZXJhY3RpbmcpIHtcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0RWxlbWVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IG5leHRFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMobmV4dEVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVkVSLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xuICB9XG4gIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gVG9hc3QuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5lbmFibGVEaXNtaXNzVHJpZ2dlcihUb2FzdCk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvYXN0KTtcblxuZXhwb3J0IHsgQWxlcnQsIEJ1dHRvbiwgQ2Fyb3VzZWwsIENvbGxhcHNlLCBEcm9wZG93biwgTW9kYWwsIE9mZmNhbnZhcywgUG9wb3ZlciwgU2Nyb2xsU3B5LCBUYWIsIFRvYXN0LCBUb29sdGlwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlBvcHBlciIsImVsZW1lbnRNYXAiLCJNYXAiLCJEYXRhIiwic2V0IiwiZWxlbWVudCIsImtleSIsImluc3RhbmNlIiwiaGFzIiwiaW5zdGFuY2VNYXAiLCJnZXQiLCJzaXplIiwiY29uc29sZSIsImVycm9yIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInJlbW92ZSIsImRlbGV0ZSIsIk1BWF9VSUQiLCJNSUxMSVNFQ09ORFNfTVVMVElQTElFUiIsIlRSQU5TSVRJT05fRU5EIiwicGFyc2VTZWxlY3RvciIsInNlbGVjdG9yIiwid2luZG93IiwiQ1NTIiwiZXNjYXBlIiwicmVwbGFjZSIsIm1hdGNoIiwiaWQiLCJ0b1R5cGUiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJ0b0xvd2VyQ2FzZSIsImdldFVJRCIsInByZWZpeCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsImdldENvbXB1dGVkU3R5bGUiLCJmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJmbG9hdFRyYW5zaXRpb25EZWxheSIsInNwbGl0IiwidHJpZ2dlclRyYW5zaXRpb25FbmQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJpc0VsZW1lbnQiLCJqcXVlcnkiLCJub2RlVHlwZSIsImdldEVsZW1lbnQiLCJsZW5ndGgiLCJxdWVyeVNlbGVjdG9yIiwiaXNWaXNpYmxlIiwiZ2V0Q2xpZW50UmVjdHMiLCJlbGVtZW50SXNWaXNpYmxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImNsb3NlZERldGFpbHMiLCJjbG9zZXN0Iiwic3VtbWFyeSIsInBhcmVudE5vZGUiLCJpc0Rpc2FibGVkIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiZGlzYWJsZWQiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJmaW5kU2hhZG93Um9vdCIsImRvY3VtZW50RWxlbWVudCIsImF0dGFjaFNoYWRvdyIsImdldFJvb3ROb2RlIiwicm9vdCIsIlNoYWRvd1Jvb3QiLCJub29wIiwicmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwiZ2V0alF1ZXJ5IiwialF1ZXJ5IiwiYm9keSIsIkRPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MiLCJvbkRPTUNvbnRlbnRMb2FkZWQiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwicHVzaCIsImlzUlRMIiwiZGlyIiwiZGVmaW5lSlF1ZXJ5UGx1Z2luIiwicGx1Z2luIiwiJCIsIm5hbWUiLCJOQU1FIiwiSlFVRVJZX05PX0NPTkZMSUNUIiwiZm4iLCJqUXVlcnlJbnRlcmZhY2UiLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJleGVjdXRlIiwicG9zc2libGVDYWxsYmFjayIsImFyZ3MiLCJkZWZhdWx0VmFsdWUiLCJleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uIiwidHJhbnNpdGlvbkVsZW1lbnQiLCJ3YWl0Rm9yVHJhbnNpdGlvbiIsImR1cmF0aW9uUGFkZGluZyIsImVtdWxhdGVkRHVyYXRpb24iLCJjYWxsZWQiLCJoYW5kbGVyIiwidGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJnZXROZXh0QWN0aXZlRWxlbWVudCIsImxpc3QiLCJhY3RpdmVFbGVtZW50Iiwic2hvdWxkR2V0TmV4dCIsImlzQ3ljbGVBbGxvd2VkIiwibGlzdExlbmd0aCIsImluZGV4IiwiaW5kZXhPZiIsIm1heCIsIm1pbiIsIm5hbWVzcGFjZVJlZ2V4Iiwic3RyaXBOYW1lUmVnZXgiLCJzdHJpcFVpZFJlZ2V4IiwiZXZlbnRSZWdpc3RyeSIsInVpZEV2ZW50IiwiY3VzdG9tRXZlbnRzIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJuYXRpdmVFdmVudHMiLCJTZXQiLCJtYWtlRXZlbnRVaWQiLCJ1aWQiLCJnZXRFbGVtZW50RXZlbnRzIiwiYm9vdHN0cmFwSGFuZGxlciIsImV2ZW50IiwiaHlkcmF0ZU9iaiIsImRlbGVnYXRlVGFyZ2V0Iiwib25lT2ZmIiwiRXZlbnRIYW5kbGVyIiwib2ZmIiwidHlwZSIsImFwcGx5IiwiYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIiLCJkb21FbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJkb21FbGVtZW50IiwiZmluZEhhbmRsZXIiLCJldmVudHMiLCJjYWxsYWJsZSIsImRlbGVnYXRpb25TZWxlY3RvciIsInZhbHVlcyIsImZpbmQiLCJub3JtYWxpemVQYXJhbWV0ZXJzIiwib3JpZ2luYWxUeXBlRXZlbnQiLCJkZWxlZ2F0aW9uRnVuY3Rpb24iLCJpc0RlbGVnYXRlZCIsInR5cGVFdmVudCIsImdldFR5cGVFdmVudCIsImFkZEhhbmRsZXIiLCJ3cmFwRnVuY3Rpb24iLCJyZWxhdGVkVGFyZ2V0IiwiaGFuZGxlcnMiLCJwcmV2aW91c0Z1bmN0aW9uIiwicmVtb3ZlSGFuZGxlciIsIkJvb2xlYW4iLCJyZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMiLCJuYW1lc3BhY2UiLCJzdG9yZUVsZW1lbnRFdmVudCIsImhhbmRsZXJLZXkiLCJlbnRyaWVzIiwiaW5jbHVkZXMiLCJvbiIsIm9uZSIsImluTmFtZXNwYWNlIiwiaXNOYW1lc3BhY2UiLCJzdGFydHNXaXRoIiwiZWxlbWVudEV2ZW50Iiwic2xpY2UiLCJrZXlIYW5kbGVycyIsInRyaWdnZXIiLCJqUXVlcnlFdmVudCIsImJ1YmJsZXMiLCJuYXRpdmVEaXNwYXRjaCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZXZ0IiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwib2JqIiwibWV0YSIsInZhbHVlIiwiX3VudXNlZCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwibm9ybWFsaXplRGF0YSIsIkpTT04iLCJwYXJzZSIsImRlY29kZVVSSUNvbXBvbmVudCIsIm5vcm1hbGl6ZURhdGFLZXkiLCJjaHIiLCJNYW5pcHVsYXRvciIsInNldERhdGFBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVEYXRhQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0RGF0YUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiYnNLZXlzIiwiZGF0YXNldCIsImZpbHRlciIsInB1cmVLZXkiLCJjaGFyQXQiLCJnZXREYXRhQXR0cmlidXRlIiwiQ29uZmlnIiwiRGVmYXVsdCIsIkRlZmF1bHRUeXBlIiwiRXJyb3IiLCJfZ2V0Q29uZmlnIiwiY29uZmlnIiwiX21lcmdlQ29uZmlnT2JqIiwiX2NvbmZpZ0FmdGVyTWVyZ2UiLCJfdHlwZUNoZWNrQ29uZmlnIiwianNvbkNvbmZpZyIsImNvbnN0cnVjdG9yIiwiY29uZmlnVHlwZXMiLCJwcm9wZXJ0eSIsImV4cGVjdGVkVHlwZXMiLCJ2YWx1ZVR5cGUiLCJSZWdFeHAiLCJ0ZXN0IiwiVHlwZUVycm9yIiwidG9VcHBlckNhc2UiLCJWRVJTSU9OIiwiQmFzZUNvbXBvbmVudCIsIl9lbGVtZW50IiwiX2NvbmZpZyIsIkRBVEFfS0VZIiwiZGlzcG9zZSIsIkVWRU5UX0tFWSIsInByb3BlcnR5TmFtZSIsImdldE93blByb3BlcnR5TmFtZXMiLCJfcXVldWVDYWxsYmFjayIsImlzQW5pbWF0ZWQiLCJnZXRJbnN0YW5jZSIsImdldE9yQ3JlYXRlSW5zdGFuY2UiLCJldmVudE5hbWUiLCJnZXRTZWxlY3RvciIsImhyZWZBdHRyaWJ1dGUiLCJ0cmltIiwibWFwIiwic2VsIiwiam9pbiIsIlNlbGVjdG9yRW5naW5lIiwiY29uY2F0IiwiRWxlbWVudCIsImZpbmRPbmUiLCJjaGlsZHJlbiIsImNoaWxkIiwibWF0Y2hlcyIsInBhcmVudHMiLCJhbmNlc3RvciIsInByZXYiLCJwcmV2aW91cyIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJuZXh0IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiZm9jdXNhYmxlQ2hpbGRyZW4iLCJmb2N1c2FibGVzIiwiZWwiLCJnZXRTZWxlY3RvckZyb21FbGVtZW50IiwiZ2V0RWxlbWVudEZyb21TZWxlY3RvciIsImdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IiLCJlbmFibGVEaXNtaXNzVHJpZ2dlciIsImNvbXBvbmVudCIsIm1ldGhvZCIsImNsaWNrRXZlbnQiLCJ0YWdOYW1lIiwiTkFNRSRmIiwiREFUQV9LRVkkYSIsIkVWRU5UX0tFWSRiIiwiRVZFTlRfQ0xPU0UiLCJFVkVOVF9DTE9TRUQiLCJDTEFTU19OQU1FX0ZBREUkNSIsIkNMQVNTX05BTUVfU0hPVyQ4IiwiQWxlcnQiLCJjbG9zZSIsImNsb3NlRXZlbnQiLCJfZGVzdHJveUVsZW1lbnQiLCJlYWNoIiwiZGF0YSIsIk5BTUUkZSIsIkRBVEFfS0VZJDkiLCJFVkVOVF9LRVkkYSIsIkRBVEFfQVBJX0tFWSQ2IiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMyIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDUiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ2IiwiQnV0dG9uIiwidG9nZ2xlIiwiYnV0dG9uIiwiTkFNRSRkIiwiRVZFTlRfS0VZJDkiLCJFVkVOVF9UT1VDSFNUQVJUIiwiRVZFTlRfVE9VQ0hNT1ZFIiwiRVZFTlRfVE9VQ0hFTkQiLCJFVkVOVF9QT0lOVEVSRE9XTiIsIkVWRU5UX1BPSU5URVJVUCIsIlBPSU5URVJfVFlQRV9UT1VDSCIsIlBPSU5URVJfVFlQRV9QRU4iLCJDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQiLCJTV0lQRV9USFJFU0hPTEQiLCJEZWZhdWx0JGMiLCJlbmRDYWxsYmFjayIsImxlZnRDYWxsYmFjayIsInJpZ2h0Q2FsbGJhY2siLCJEZWZhdWx0VHlwZSRjIiwiU3dpcGUiLCJpc1N1cHBvcnRlZCIsIl9kZWx0YVgiLCJfc3VwcG9ydFBvaW50ZXJFdmVudHMiLCJQb2ludGVyRXZlbnQiLCJfaW5pdEV2ZW50cyIsIl9zdGFydCIsInRvdWNoZXMiLCJjbGllbnRYIiwiX2V2ZW50SXNQb2ludGVyUGVuVG91Y2giLCJfZW5kIiwiX2hhbmRsZVN3aXBlIiwiX21vdmUiLCJhYnNEZWx0YVgiLCJhYnMiLCJkaXJlY3Rpb24iLCJhZGQiLCJwb2ludGVyVHlwZSIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiTkFNRSRjIiwiREFUQV9LRVkkOCIsIkVWRU5UX0tFWSQ4IiwiREFUQV9BUElfS0VZJDUiLCJBUlJPV19MRUZUX0tFWSQxIiwiQVJST1dfUklHSFRfS0VZJDEiLCJUT1VDSEVWRU5UX0NPTVBBVF9XQUlUIiwiT1JERVJfTkVYVCIsIk9SREVSX1BSRVYiLCJESVJFQ1RJT05fTEVGVCIsIkRJUkVDVElPTl9SSUdIVCIsIkVWRU5UX1NMSURFIiwiRVZFTlRfU0xJRCIsIkVWRU5UX0tFWURPV04kMSIsIkVWRU5UX01PVVNFRU5URVIkMSIsIkVWRU5UX01PVVNFTEVBVkUkMSIsIkVWRU5UX0RSQUdfU1RBUlQiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDMiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ1IiwiQ0xBU1NfTkFNRV9DQVJPVVNFTCIsIkNMQVNTX05BTUVfQUNUSVZFJDIiLCJDTEFTU19OQU1FX1NMSURFIiwiQ0xBU1NfTkFNRV9FTkQiLCJDTEFTU19OQU1FX1NUQVJUIiwiQ0xBU1NfTkFNRV9ORVhUIiwiQ0xBU1NfTkFNRV9QUkVWIiwiU0VMRUNUT1JfQUNUSVZFIiwiU0VMRUNUT1JfSVRFTSIsIlNFTEVDVE9SX0FDVElWRV9JVEVNIiwiU0VMRUNUT1JfSVRFTV9JTUciLCJTRUxFQ1RPUl9JTkRJQ0FUT1JTIiwiU0VMRUNUT1JfREFUQV9TTElERSIsIlNFTEVDVE9SX0RBVEFfUklERSIsIktFWV9UT19ESVJFQ1RJT04iLCJEZWZhdWx0JGIiLCJpbnRlcnZhbCIsImtleWJvYXJkIiwicGF1c2UiLCJyaWRlIiwidG91Y2giLCJ3cmFwIiwiRGVmYXVsdFR5cGUkYiIsIkNhcm91c2VsIiwiX2ludGVydmFsIiwiX2FjdGl2ZUVsZW1lbnQiLCJfaXNTbGlkaW5nIiwidG91Y2hUaW1lb3V0IiwiX3N3aXBlSGVscGVyIiwiX2luZGljYXRvcnNFbGVtZW50IiwiX2FkZEV2ZW50TGlzdGVuZXJzIiwiY3ljbGUiLCJfc2xpZGUiLCJuZXh0V2hlblZpc2libGUiLCJoaWRkZW4iLCJfY2xlYXJJbnRlcnZhbCIsIl91cGRhdGVJbnRlcnZhbCIsInNldEludGVydmFsIiwiX21heWJlRW5hYmxlQ3ljbGUiLCJ0byIsIml0ZW1zIiwiX2dldEl0ZW1zIiwiYWN0aXZlSW5kZXgiLCJfZ2V0SXRlbUluZGV4IiwiX2dldEFjdGl2ZSIsIm9yZGVyIiwiZGVmYXVsdEludGVydmFsIiwiX2tleWRvd24iLCJfYWRkVG91Y2hFdmVudExpc3RlbmVycyIsImltZyIsImVuZENhbGxCYWNrIiwiY2xlYXJUaW1lb3V0Iiwic3dpcGVDb25maWciLCJfZGlyZWN0aW9uVG9PcmRlciIsIl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50IiwiYWN0aXZlSW5kaWNhdG9yIiwibmV3QWN0aXZlSW5kaWNhdG9yIiwiZWxlbWVudEludGVydmFsIiwicGFyc2VJbnQiLCJpc05leHQiLCJuZXh0RWxlbWVudCIsIm5leHRFbGVtZW50SW5kZXgiLCJ0cmlnZ2VyRXZlbnQiLCJfb3JkZXJUb0RpcmVjdGlvbiIsInNsaWRlRXZlbnQiLCJpc0N5Y2xpbmciLCJkaXJlY3Rpb25hbENsYXNzTmFtZSIsIm9yZGVyQ2xhc3NOYW1lIiwiY29tcGxldGVDYWxsQmFjayIsIl9pc0FuaW1hdGVkIiwiY2xlYXJJbnRlcnZhbCIsImNhcm91c2VsIiwic2xpZGVJbmRleCIsImNhcm91c2VscyIsIk5BTUUkYiIsIkRBVEFfS0VZJDciLCJFVkVOVF9LRVkkNyIsIkRBVEFfQVBJX0tFWSQ0IiwiRVZFTlRfU0hPVyQ2IiwiRVZFTlRfU0hPV04kNiIsIkVWRU5UX0hJREUkNiIsIkVWRU5UX0hJRERFTiQ2IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCIsIkNMQVNTX05BTUVfU0hPVyQ3IiwiQ0xBU1NfTkFNRV9DT0xMQVBTRSIsIkNMQVNTX05BTUVfQ09MTEFQU0lORyIsIkNMQVNTX05BTUVfQ09MTEFQU0VEIiwiQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4iLCJDTEFTU19OQU1FX0hPUklaT05UQUwiLCJXSURUSCIsIkhFSUdIVCIsIlNFTEVDVE9SX0FDVElWRVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0IiwiRGVmYXVsdCRhIiwicGFyZW50IiwiRGVmYXVsdFR5cGUkYSIsIkNvbGxhcHNlIiwiX2lzVHJhbnNpdGlvbmluZyIsIl90cmlnZ2VyQXJyYXkiLCJ0b2dnbGVMaXN0IiwiZWxlbSIsImZpbHRlckVsZW1lbnQiLCJmb3VuZEVsZW1lbnQiLCJfaW5pdGlhbGl6ZUNoaWxkcmVuIiwiX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsIl9pc1Nob3duIiwiaGlkZSIsInNob3ciLCJhY3RpdmVDaGlsZHJlbiIsIl9nZXRGaXJzdExldmVsQ2hpbGRyZW4iLCJzdGFydEV2ZW50IiwiYWN0aXZlSW5zdGFuY2UiLCJkaW1lbnNpb24iLCJfZ2V0RGltZW5zaW9uIiwic3R5bGUiLCJjb21wbGV0ZSIsImNhcGl0YWxpemVkRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNlbGVjdGVkIiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwiTkFNRSRhIiwiREFUQV9LRVkkNiIsIkVWRU5UX0tFWSQ2IiwiREFUQV9BUElfS0VZJDMiLCJFU0NBUEVfS0VZJDIiLCJUQUJfS0VZJDEiLCJBUlJPV19VUF9LRVkkMSIsIkFSUk9XX0RPV05fS0VZJDEiLCJSSUdIVF9NT1VTRV9CVVRUT04iLCJFVkVOVF9ISURFJDUiLCJFVkVOVF9ISURERU4kNSIsIkVWRU5UX1NIT1ckNSIsIkVWRU5UX1NIT1dOJDUiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQzIiwiRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSIsIkVWRU5UX0tFWVVQX0RBVEFfQVBJIiwiQ0xBU1NfTkFNRV9TSE9XJDYiLCJDTEFTU19OQU1FX0RST1BVUCIsIkNMQVNTX05BTUVfRFJPUEVORCIsIkNMQVNTX05BTUVfRFJPUFNUQVJUIiwiQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9DRU5URVIiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzIiwiU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04iLCJTRUxFQ1RPUl9NRU5VIiwiU0VMRUNUT1JfTkFWQkFSIiwiU0VMRUNUT1JfTkFWQkFSX05BViIsIlNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMiLCJQTEFDRU1FTlRfVE9QIiwiUExBQ0VNRU5UX1RPUEVORCIsIlBMQUNFTUVOVF9CT1RUT00iLCJQTEFDRU1FTlRfQk9UVE9NRU5EIiwiUExBQ0VNRU5UX1JJR0hUIiwiUExBQ0VNRU5UX0xFRlQiLCJQTEFDRU1FTlRfVE9QQ0VOVEVSIiwiUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiIsIkRlZmF1bHQkOSIsImF1dG9DbG9zZSIsImJvdW5kYXJ5IiwiZGlzcGxheSIsIm9mZnNldCIsInBvcHBlckNvbmZpZyIsInJlZmVyZW5jZSIsIkRlZmF1bHRUeXBlJDkiLCJEcm9wZG93biIsIl9wb3BwZXIiLCJfcGFyZW50IiwiX21lbnUiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwic2hvd0V2ZW50IiwiX2NyZWF0ZVBvcHBlciIsImZvY3VzIiwiX2NvbXBsZXRlSGlkZSIsImRlc3Ryb3kiLCJ1cGRhdGUiLCJoaWRlRXZlbnQiLCJyZWZlcmVuY2VFbGVtZW50IiwiX2dldFBvcHBlckNvbmZpZyIsImNyZWF0ZVBvcHBlciIsIl9nZXRQbGFjZW1lbnQiLCJwYXJlbnREcm9wZG93biIsImlzRW5kIiwiX2dldE9mZnNldCIsInBvcHBlckRhdGEiLCJkZWZhdWx0QnNQb3BwZXJDb25maWciLCJwbGFjZW1lbnQiLCJtb2RpZmllcnMiLCJvcHRpb25zIiwiZW5hYmxlZCIsIl9zZWxlY3RNZW51SXRlbSIsImNsZWFyTWVudXMiLCJvcGVuVG9nZ2xlcyIsImNvbnRleHQiLCJjb21wb3NlZFBhdGgiLCJpc01lbnVUYXJnZXQiLCJkYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJpc0lucHV0IiwiaXNFc2NhcGVFdmVudCIsImlzVXBPckRvd25FdmVudCIsImdldFRvZ2dsZUJ1dHRvbiIsInN0b3BQcm9wYWdhdGlvbiIsIk5BTUUkOSIsIkNMQVNTX05BTUVfRkFERSQ0IiwiQ0xBU1NfTkFNRV9TSE9XJDUiLCJFVkVOVF9NT1VTRURPV04iLCJEZWZhdWx0JDgiLCJjbGFzc05hbWUiLCJjbGlja0NhbGxiYWNrIiwicm9vdEVsZW1lbnQiLCJEZWZhdWx0VHlwZSQ4IiwiQmFja2Ryb3AiLCJfaXNBcHBlbmRlZCIsIl9hcHBlbmQiLCJfZ2V0RWxlbWVudCIsIl9lbXVsYXRlQW5pbWF0aW9uIiwiYmFja2Ryb3AiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kIiwiTkFNRSQ4IiwiREFUQV9LRVkkNSIsIkVWRU5UX0tFWSQ1IiwiRVZFTlRfRk9DVVNJTiQyIiwiRVZFTlRfS0VZRE9XTl9UQUIiLCJUQUJfS0VZIiwiVEFCX05BVl9GT1JXQVJEIiwiVEFCX05BVl9CQUNLV0FSRCIsIkRlZmF1bHQkNyIsImF1dG9mb2N1cyIsInRyYXBFbGVtZW50IiwiRGVmYXVsdFR5cGUkNyIsIkZvY3VzVHJhcCIsIl9pc0FjdGl2ZSIsIl9sYXN0VGFiTmF2RGlyZWN0aW9uIiwiYWN0aXZhdGUiLCJfaGFuZGxlRm9jdXNpbiIsIl9oYW5kbGVLZXlkb3duIiwiZGVhY3RpdmF0ZSIsImVsZW1lbnRzIiwic2hpZnRLZXkiLCJTRUxFQ1RPUl9GSVhFRF9DT05URU5UIiwiU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQiLCJQUk9QRVJUWV9QQURESU5HIiwiUFJPUEVSVFlfTUFSR0lOIiwiU2Nyb2xsQmFySGVscGVyIiwiZ2V0V2lkdGgiLCJkb2N1bWVudFdpZHRoIiwiY2xpZW50V2lkdGgiLCJpbm5lcldpZHRoIiwid2lkdGgiLCJfZGlzYWJsZU92ZXJGbG93IiwiX3NldEVsZW1lbnRBdHRyaWJ1dGVzIiwiY2FsY3VsYXRlZFZhbHVlIiwicmVzZXQiLCJfcmVzZXRFbGVtZW50QXR0cmlidXRlcyIsImlzT3ZlcmZsb3dpbmciLCJfc2F2ZUluaXRpYWxBdHRyaWJ1dGUiLCJvdmVyZmxvdyIsInN0eWxlUHJvcGVydHkiLCJzY3JvbGxiYXJXaWR0aCIsIm1hbmlwdWxhdGlvbkNhbGxCYWNrIiwic2V0UHJvcGVydHkiLCJfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayIsImFjdHVhbFZhbHVlIiwicmVtb3ZlUHJvcGVydHkiLCJjYWxsQmFjayIsIk5BTUUkNyIsIkRBVEFfS0VZJDQiLCJFVkVOVF9LRVkkNCIsIkRBVEFfQVBJX0tFWSQyIiwiRVNDQVBFX0tFWSQxIiwiRVZFTlRfSElERSQ0IiwiRVZFTlRfSElERV9QUkVWRU5URUQkMSIsIkVWRU5UX0hJRERFTiQ0IiwiRVZFTlRfU0hPVyQ0IiwiRVZFTlRfU0hPV04kNCIsIkVWRU5UX1JFU0laRSQxIiwiRVZFTlRfQ0xJQ0tfRElTTUlTUyIsIkVWRU5UX01PVVNFRE9XTl9ESVNNSVNTIiwiRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQyIiwiQ0xBU1NfTkFNRV9PUEVOIiwiQ0xBU1NfTkFNRV9GQURFJDMiLCJDTEFTU19OQU1FX1NIT1ckNCIsIkNMQVNTX05BTUVfU1RBVElDIiwiT1BFTl9TRUxFQ1RPUiQxIiwiU0VMRUNUT1JfRElBTE9HIiwiU0VMRUNUT1JfTU9EQUxfQk9EWSIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDIiLCJEZWZhdWx0JDYiLCJEZWZhdWx0VHlwZSQ2IiwiTW9kYWwiLCJfZGlhbG9nIiwiX2JhY2tkcm9wIiwiX2luaXRpYWxpemVCYWNrRHJvcCIsIl9mb2N1c3RyYXAiLCJfaW5pdGlhbGl6ZUZvY3VzVHJhcCIsIl9zY3JvbGxCYXIiLCJfYWRqdXN0RGlhbG9nIiwiX3Nob3dFbGVtZW50IiwiX2hpZGVNb2RhbCIsImhhbmRsZVVwZGF0ZSIsInNjcm9sbFRvcCIsIm1vZGFsQm9keSIsInRyYW5zaXRpb25Db21wbGV0ZSIsIl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uIiwiZXZlbnQyIiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJpbml0aWFsT3ZlcmZsb3dZIiwib3ZlcmZsb3dZIiwiaXNCb2R5T3ZlcmZsb3dpbmciLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImFscmVhZHlPcGVuIiwiTkFNRSQ2IiwiREFUQV9LRVkkMyIsIkVWRU5UX0tFWSQzIiwiREFUQV9BUElfS0VZJDEiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDIiLCJFU0NBUEVfS0VZIiwiQ0xBU1NfTkFNRV9TSE9XJDMiLCJDTEFTU19OQU1FX1NIT1dJTkckMSIsIkNMQVNTX05BTUVfSElESU5HIiwiQ0xBU1NfTkFNRV9CQUNLRFJPUCIsIk9QRU5fU0VMRUNUT1IiLCJFVkVOVF9TSE9XJDMiLCJFVkVOVF9TSE9XTiQzIiwiRVZFTlRfSElERSQzIiwiRVZFTlRfSElERV9QUkVWRU5URUQiLCJFVkVOVF9ISURERU4kMyIsIkVWRU5UX1JFU0laRSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDEiLCJFVkVOVF9LRVlET1dOX0RJU01JU1MiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxIiwiRGVmYXVsdCQ1Iiwic2Nyb2xsIiwiRGVmYXVsdFR5cGUkNSIsIk9mZmNhbnZhcyIsImJsdXIiLCJjb21wbGV0ZUNhbGxiYWNrIiwicG9zaXRpb24iLCJBUklBX0FUVFJJQlVURV9QQVRURVJOIiwiRGVmYXVsdEFsbG93bGlzdCIsImEiLCJhcmVhIiwiYiIsImJyIiwiY29sIiwiY29kZSIsImRkIiwiZGl2IiwiZGwiLCJkdCIsImVtIiwiaHIiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJpIiwibGkiLCJvbCIsInAiLCJwcmUiLCJzIiwic21hbGwiLCJzcGFuIiwic3ViIiwic3VwIiwic3Ryb25nIiwidSIsInVsIiwidXJpQXR0cmlidXRlcyIsIlNBRkVfVVJMX1BBVFRFUk4iLCJhbGxvd2VkQXR0cmlidXRlIiwiYXR0cmlidXRlIiwiYWxsb3dlZEF0dHJpYnV0ZUxpc3QiLCJhdHRyaWJ1dGVOYW1lIiwibm9kZU5hbWUiLCJub2RlVmFsdWUiLCJhdHRyaWJ1dGVSZWdleCIsInNvbWUiLCJyZWdleCIsInNhbml0aXplSHRtbCIsInVuc2FmZUh0bWwiLCJhbGxvd0xpc3QiLCJzYW5pdGl6ZUZ1bmN0aW9uIiwiZG9tUGFyc2VyIiwiRE9NUGFyc2VyIiwiY3JlYXRlZERvY3VtZW50IiwicGFyc2VGcm9tU3RyaW5nIiwiZWxlbWVudE5hbWUiLCJhdHRyaWJ1dGVMaXN0IiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJpbm5lckhUTUwiLCJOQU1FJDUiLCJEZWZhdWx0JDQiLCJjb250ZW50IiwiZXh0cmFDbGFzcyIsImh0bWwiLCJzYW5pdGl6ZSIsInNhbml0aXplRm4iLCJ0ZW1wbGF0ZSIsIkRlZmF1bHRUeXBlJDQiLCJEZWZhdWx0Q29udGVudFR5cGUiLCJlbnRyeSIsIlRlbXBsYXRlRmFjdG9yeSIsImdldENvbnRlbnQiLCJfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24iLCJoYXNDb250ZW50IiwiY2hhbmdlQ29udGVudCIsIl9jaGVja0NvbnRlbnQiLCJ0b0h0bWwiLCJ0ZW1wbGF0ZVdyYXBwZXIiLCJfbWF5YmVTYW5pdGl6ZSIsInRleHQiLCJfc2V0Q29udGVudCIsImFyZyIsInRlbXBsYXRlRWxlbWVudCIsIl9wdXRFbGVtZW50SW5UZW1wbGF0ZSIsInRleHRDb250ZW50IiwiTkFNRSQ0IiwiRElTQUxMT1dFRF9BVFRSSUJVVEVTIiwiQ0xBU1NfTkFNRV9GQURFJDIiLCJDTEFTU19OQU1FX01PREFMIiwiQ0xBU1NfTkFNRV9TSE9XJDIiLCJTRUxFQ1RPUl9UT09MVElQX0lOTkVSIiwiU0VMRUNUT1JfTU9EQUwiLCJFVkVOVF9NT0RBTF9ISURFIiwiVFJJR0dFUl9IT1ZFUiIsIlRSSUdHRVJfRk9DVVMiLCJUUklHR0VSX0NMSUNLIiwiVFJJR0dFUl9NQU5VQUwiLCJFVkVOVF9ISURFJDIiLCJFVkVOVF9ISURERU4kMiIsIkVWRU5UX1NIT1ckMiIsIkVWRU5UX1NIT1dOJDIiLCJFVkVOVF9JTlNFUlRFRCIsIkVWRU5UX0NMSUNLJDEiLCJFVkVOVF9GT0NVU0lOJDEiLCJFVkVOVF9GT0NVU09VVCQxIiwiRVZFTlRfTU9VU0VFTlRFUiIsIkVWRU5UX01PVVNFTEVBVkUiLCJBdHRhY2htZW50TWFwIiwiQVVUTyIsIlRPUCIsIlJJR0hUIiwiQk9UVE9NIiwiTEVGVCIsIkRlZmF1bHQkMyIsImFuaW1hdGlvbiIsImNvbnRhaW5lciIsImN1c3RvbUNsYXNzIiwiZGVsYXkiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJ0aXRsZSIsIkRlZmF1bHRUeXBlJDMiLCJUb29sdGlwIiwiX2lzRW5hYmxlZCIsIl90aW1lb3V0IiwiX2lzSG92ZXJlZCIsIl9hY3RpdmVUcmlnZ2VyIiwiX3RlbXBsYXRlRmFjdG9yeSIsIl9uZXdDb250ZW50IiwidGlwIiwiX3NldExpc3RlbmVycyIsIl9maXhUaXRsZSIsImVuYWJsZSIsImRpc2FibGUiLCJ0b2dnbGVFbmFibGVkIiwiX2xlYXZlIiwiX2VudGVyIiwiX2hpZGVNb2RhbEhhbmRsZXIiLCJfZGlzcG9zZVBvcHBlciIsIl9pc1dpdGhDb250ZW50Iiwic2hhZG93Um9vdCIsImlzSW5UaGVEb20iLCJvd25lckRvY3VtZW50IiwiX2dldFRpcEVsZW1lbnQiLCJfaXNXaXRoQWN0aXZlVHJpZ2dlciIsIl9nZXRUaXRsZSIsIl9jcmVhdGVUaXBFbGVtZW50IiwiX2dldENvbnRlbnRGb3JUZW1wbGF0ZSIsIl9nZXRUZW1wbGF0ZUZhY3RvcnkiLCJ0aXBJZCIsInNldENvbnRlbnQiLCJfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0IiwiX2dldERlbGVnYXRlQ29uZmlnIiwiYXR0YWNobWVudCIsInBoYXNlIiwic3RhdGUiLCJ0cmlnZ2VycyIsImV2ZW50SW4iLCJldmVudE91dCIsIl9zZXRUaW1lb3V0IiwidGltZW91dCIsImRhdGFBdHRyaWJ1dGVzIiwiZGF0YUF0dHJpYnV0ZSIsIk5BTUUkMyIsIlNFTEVDVE9SX1RJVExFIiwiU0VMRUNUT1JfQ09OVEVOVCIsIkRlZmF1bHQkMiIsIkRlZmF1bHRUeXBlJDIiLCJQb3BvdmVyIiwiX2dldENvbnRlbnQiLCJOQU1FJDIiLCJEQVRBX0tFWSQyIiwiRVZFTlRfS0VZJDIiLCJEQVRBX0FQSV9LRVkiLCJFVkVOVF9BQ1RJVkFURSIsIkVWRU5UX0NMSUNLIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQxIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNIiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMSIsIlNFTEVDVE9SX0RBVEFfU1BZIiwiU0VMRUNUT1JfVEFSR0VUX0xJTktTIiwiU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAiLCJTRUxFQ1RPUl9OQVZfTElOS1MiLCJTRUxFQ1RPUl9OQVZfSVRFTVMiLCJTRUxFQ1RPUl9MSVNUX0lURU1TIiwiU0VMRUNUT1JfTElOS19JVEVNUyIsIlNFTEVDVE9SX0RST1BET1dOIiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEiLCJEZWZhdWx0JDEiLCJyb290TWFyZ2luIiwic21vb3RoU2Nyb2xsIiwidGhyZXNob2xkIiwiRGVmYXVsdFR5cGUkMSIsIlNjcm9sbFNweSIsIl90YXJnZXRMaW5rcyIsIl9vYnNlcnZhYmxlU2VjdGlvbnMiLCJfcm9vdEVsZW1lbnQiLCJfYWN0aXZlVGFyZ2V0IiwiX29ic2VydmVyIiwiX3ByZXZpb3VzU2Nyb2xsRGF0YSIsInZpc2libGVFbnRyeVRvcCIsInBhcmVudFNjcm9sbFRvcCIsInJlZnJlc2giLCJfaW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcyIsIl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCIsImRpc2Nvbm5lY3QiLCJfZ2V0TmV3T2JzZXJ2ZXIiLCJzZWN0aW9uIiwib2JzZXJ2ZSIsIm9ic2VydmFibGVTZWN0aW9uIiwiaGFzaCIsImhlaWdodCIsIm9mZnNldFRvcCIsInNjcm9sbFRvIiwidG9wIiwiYmVoYXZpb3IiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIl9vYnNlcnZlckNhbGxiYWNrIiwidGFyZ2V0RWxlbWVudCIsIl9wcm9jZXNzIiwidXNlclNjcm9sbHNEb3duIiwiaXNJbnRlcnNlY3RpbmciLCJfY2xlYXJBY3RpdmVDbGFzcyIsImVudHJ5SXNMb3dlclRoYW5QcmV2aW91cyIsInRhcmdldExpbmtzIiwiYW5jaG9yIiwiZGVjb2RlVVJJIiwiX2FjdGl2YXRlUGFyZW50cyIsImxpc3RHcm91cCIsIml0ZW0iLCJhY3RpdmVOb2RlcyIsIm5vZGUiLCJzcHkiLCJOQU1FJDEiLCJEQVRBX0tFWSQxIiwiRVZFTlRfS0VZJDEiLCJFVkVOVF9ISURFJDEiLCJFVkVOVF9ISURERU4kMSIsIkVWRU5UX1NIT1ckMSIsIkVWRU5UX1NIT1dOJDEiLCJFVkVOVF9DTElDS19EQVRBX0FQSSIsIkVWRU5UX0tFWURPV04iLCJFVkVOVF9MT0FEX0RBVEFfQVBJIiwiQVJST1dfTEVGVF9LRVkiLCJBUlJPV19SSUdIVF9LRVkiLCJBUlJPV19VUF9LRVkiLCJBUlJPV19ET1dOX0tFWSIsIkhPTUVfS0VZIiwiRU5EX0tFWSIsIkNMQVNTX05BTUVfQUNUSVZFIiwiQ0xBU1NfTkFNRV9GQURFJDEiLCJDTEFTU19OQU1FX1NIT1ckMSIsIkNMQVNTX0RST1BET1dOIiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFIiwiU0VMRUNUT1JfRFJPUERPV05fTUVOVSIsIk5PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUiLCJTRUxFQ1RPUl9UQUJfUEFORUwiLCJTRUxFQ1RPUl9PVVRFUiIsIlNFTEVDVE9SX0lOTkVSIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUiLCJTRUxFQ1RPUl9JTk5FUl9FTEVNIiwiU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFIiwiVGFiIiwiX3NldEluaXRpYWxBdHRyaWJ1dGVzIiwiX2dldENoaWxkcmVuIiwiaW5uZXJFbGVtIiwiX2VsZW1Jc0FjdGl2ZSIsImFjdGl2ZSIsIl9nZXRBY3RpdmVFbGVtIiwiX2RlYWN0aXZhdGUiLCJfYWN0aXZhdGUiLCJyZWxhdGVkRWxlbSIsIl90b2dnbGVEcm9wRG93biIsIm5leHRBY3RpdmVFbGVtZW50IiwicHJldmVudFNjcm9sbCIsIl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyIsIl9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQiLCJfZ2V0SW5uZXJFbGVtZW50IiwiaXNBY3RpdmUiLCJvdXRlckVsZW0iLCJfZ2V0T3V0ZXJFbGVtZW50IiwiX3NldEluaXRpYWxBdHRyaWJ1dGVzT25UYXJnZXRQYW5lbCIsIm9wZW4iLCJFVkVOVF9NT1VTRU9WRVIiLCJFVkVOVF9NT1VTRU9VVCIsIkVWRU5UX0ZPQ1VTSU4iLCJFVkVOVF9GT0NVU09VVCIsIkVWRU5UX0hJREUiLCJFVkVOVF9ISURERU4iLCJFVkVOVF9TSE9XIiwiRVZFTlRfU0hPV04iLCJDTEFTU19OQU1FX0ZBREUiLCJDTEFTU19OQU1FX0hJREUiLCJDTEFTU19OQU1FX1NIT1ciLCJDTEFTU19OQU1FX1NIT1dJTkciLCJhdXRvaGlkZSIsIlRvYXN0IiwiX2hhc01vdXNlSW50ZXJhY3Rpb24iLCJfaGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiIsIl9jbGVhclRpbWVvdXQiLCJfbWF5YmVTY2hlZHVsZUhpZGUiLCJpc1Nob3duIiwiX29uSW50ZXJhY3Rpb24iLCJpc0ludGVyYWN0aW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bootstrap/dist/js/bootstrap.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bootstrap/dist/css/bootstrap.min.css":
/*!***********************************************************!*\
  !*** ./node_modules/bootstrap/dist/css/bootstrap.min.css ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"371e7aed5ab2\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zaW1wbGUtdWkvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzQ2NTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIzNzFlN2FlZDVhYjJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bootstrap/dist/css/bootstrap.min.css\n");

/***/ })

};
;